\chapter{Declaring Variables}
let and const are two relatively new types of variable declarations in JavaScript. let is similar to var in some respects, but allows users to avoid some of the common "gotchas" that users run into in JavaScript. const is an audmentation of let in that it prevents re-assignment to a variable.

With TypeScript being a superset of JavaScript, the language naturally supports let and const. Here will be more elaboration on these new declarations and why they're preferable to var.

\section{var declarations}
Declaring a variable in JavaScript has always traditionally been done with the var keyword. We can also declare a variable inside of a function and we can also access those same variables within other functions.

\subsubsection{Scoping rules}
var declarations have some odd scoping rules for those used to other languages. var declarations are accessible anywhere within their containning function, module, namespace or global scope - all which we'll fo over later on - regardless of the containing block. Some people call this var-scoping or function-scoping. Parameters are also function scoped.

These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:
\begin{lstlisting}
    function sumMatrix(matrix: number[][]){
        var sum = 0;
        for(var i = 0; i < matrix.length; i++){
            var currentRow = matrix[i];
            for(var i = 0; i < currentRow.length; i++){
                sum += currentRow[i];
            }
        }
        return sum;
    }
\end{lstlisting}

Maybe it was easy to spot out for some, but the inner for-loop will accidentally overwrite the variable i because i refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip thorugh code reviews and can be endless source of frustration.

\subsubsection{Variable capturing quirks}
With the next piece of code in mind, try to guess what the output will be:
\begin{lstlisting}
    for(var i = 0; i < 10; i++)
    {
        setTimeout(function(){console.log(i);}, 100 * i);
    }
\end{lstlisting}

For those unfamiliar, setTimeout will try to execute a function after a certain number of milliseconds (thorugh waiting for anything else to stop running). The output of this code will be 10 times the number 10 being displayed rather then the list of numbers between 0 and 9. This is because every function expression we pass to setTimeout actually refers to the same i from the same scope. setTimeout will run a function after some number of milliseconds, but only after the for loop has stopped executing: By the time the for loop has stopped executing, the value of i is 10. So each time the given function gets called, it will print out 10.

A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture i at each iteration:
\begin{lstlisting}
    for(var i = 0l i < 10; i++){
        //capture the current state of 'i'
        //by invoking a function with its current value
        (function(i){
            setTimeout(function() {console.log(i); }, 100 * i);
        })(i);
    }
\end{lstlisting}

This odd-looking pattern is actually pretty common. The i in the parameter list actually shadows the i declared in the for loop, but since we named them the same, we didn't have to modify the loop body too much.

\section{lst declarations}