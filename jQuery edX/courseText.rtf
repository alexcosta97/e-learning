{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\ul\f0\fs28\lang9 jQuery Notes\ulnone\par
\b\fs22 Options for adding jQuery\b0\par
To add jQuery to a web page, it's a simple as adding a reference to the jQuery javaScript file. We always want to use the minified version, signified by min in thee name, as this will reduce the amount of data passed to the user, saving both bandwidth and loading time.\par
It is possible to download from jQuery or to use a package manager such as NuGet or npm. Similarly, we have multiple options when it comes to sourcing the JavaScript file on our page.\par
The first option is to serve the file from our own server, just as we would serve any other image or script file. Because we've already downloaded the file, it's easy to simply ensure it's part of our project, deployed to our server, and then referenced in a page. However, this is yet another file that our server has to send to the user, which increases both the number of requests that our server needs to handle and the amount of bandwidth required for the server to serve a page to the user.\par
As an alternative, we can use a content delivery network, CDN. A CDN is a set of servers hosted by a third party, such as Microsoft or Google, that hosts and serves common files used for creating web pages. In fact, most common JS libraries, including Knockout, AngularJS and Bootstrap, are available on CDNs.\par
By using a CDN we save our server from having to send down the file, the users will download the file from the CDN servers rather than ours. For heavily trafficked sites this can mean a large improvement in performance. When using popular CDN, such as the one from Microsoft, there's a good chance the user will have already downloaded the file. Browsers cache files based on path names, so if the user has visited a site that used the same file from the same CDN, the browser won't need to download that file again. As a result, the page will load that much faster.\par
\par
\b Updating our page to include a reference to jQuery\b0\par
Below is the code we'll need to add jQuery to a page. We have to keep in mind that the URL of the JavaScript file will depend on where the file is located, and if we're using a CDN.\par

\pard\sl240\slmult1 <html>\par
\tab <head>\par
\tab\tab <title>Demo page</title>\par
\tab </head>\par
\tab <body>\par
\tab\tab <script src="[location of minified jQuery JavaScript file]"></script>\par
\tab\tab <script>\par
\tab\tab\tab //our custom scripts that use jQuery\par
\tab\tab </script>\par
\tab </body>\par
</html>\par

\pard\sa200\sl276\slmult1\par
\ul\b Hello jQuery\ulnone\b0\par
Now that we've obtained jQuery, and added the approptiate library to the page, it's time to actually do something with it. As per tradition, we'll do so by doing Hello World.\par
\b The magic of the $\par
\b0 In jQuery, the $ character is the shortcut of the jQuery factory, meaning that it provides access to the jQuery object and all of the power that jQuery offers. We can use $ to access global objects and functions, and, more commonly, elements and other components in the DOM.\par
The first operation we'll typically perform in any page that uses jQuery is to register a document.ready event handler. The document.ready event handler executes after everything on the page has loaded, ensuring the entire DOM is now in memory, and the jQuery library is now available.\par
There are a coupe of ways to register this event handler. The first is to access the document object in jQuery, and register an event handler with the jQuery ready event.\par
We can use:\par

\pard\sl240\slmult1 $(document).ready(function()\{\par
\tab //code here\par
\});\par
\par
Because registering an event handler with jQuery is so common, jQuery provides a shortcut. Simply passing a function into the constructor will register that function as the event handler for document.load\par
\par
$(function()\{\par
\tab //code here\par
\});\par
\par
Both of the code blocks above are semantically identical.\par
\par
\ul\b Common CSS selectors\ulnone\b0\par
In order to start manipulating HTML page dynamically you first need to locate the desired items. One of the original goals jQuery was to use pre-existing syntax, in particular CSS selectors. CSS selectors are an expressive and powerful way of locating items based on several criteria, including element type, classes and position. By using CSS selectors we can locate any item we need on a page quickly and easily.\par
\par
jQuery offers a lot of different ways to find multiple items on an HTML page. We can use executing methods, or, more commonly, by utilising the same selector syntax that CSS offers.\par
\par
\ul Basic CSS selectors\ulnone\par
The most basic CSS selector is to simply use the name of the element we're looking for. If we want all h1 elements, we can simply use h1 as our selector.\par
\par
$('h1') //selects all h1 elements\par
\par
We'll notice, just as we saw with with document.ready, we pass the appropriate text into the jQuery constructor to indicate the selector we wish to use. Because of the flexibility of JavaScript, and how jQuery was designed, this patter stays rather constant whenever we're looking to get started using jQuery in a page - we simply need to pass the appropriate text, item, or other component into the constructor and jQuery will handle it from there.\par
\par
If we go back to the CSS selectors, we can use a class and find all the particular elements of it by simply using the name of the class with a dot in front of it, just like we would when creating a CSS stylessheet.\par
\par
And, finally, if we want to find an element by its ID, we can simply use the same CSS syntax, prepending the ID with a hash.\par
\par
After selecting multiple elements, either by calling a type of element or a class, whatever method that we call after selecting them will apply to all of the elements. For example, if we want to set up a click event handler for a group of div elements, or if we want to disable all the buttons on a page, or update a set of textboxes, we can do very easily do that inside of jQuery by calling them all together.\par
\par
\ul\b Attribute based selectors\ulnone\b0\par
The HTML specification defines many attributes, such as class and style as well as allowing developers to add their own attributes. By using CSS selector syntax, we can locate items both on custom and predifined attribtues. We can find items based on a quality for an attribute.\par
\par
To find elements in which an attribute is set to a specific value, we use the equality syntax. We must note that the value that we wish to compare must be in quotes, which means we need to use both single and double quotes to create the appropriate string. While the actual quotes we use are up to us, most JavaScript developers use single quotes for normal strings and then double quotes when they need to indicate a quoted value inside of a string.\par
\par
//select **all** elements with an attribute matching the specified value\par
$('[demo-attribute="demo-value"]')\par
\par
//selects all **h1** elements with an attribute matching the specified value\par
$('h1[demo-attribute="demo-value"]')\par
\par
\b Locating items by partial attribute values\b0\par
Many frameworks, such as Bootstrap, make their magic happen by having developers add certain classes or other attributes to their HTML. Often, the values we'll be using for classes or attributes have consistent patterns or prefixes. jQuery allows us to select items by searching inside of attribute values for desired sub-strings.\par
\par
If we wish to find all elements where the value starts with a string, we use the ^= operator:\par
$('[class^="col"]')\par
\par
If we wish to find all elements where the value contains a string, we use the *= operator:\par
$('[class*="md"]')\par
\par
There are several more operators available. We can check the documentation for a full list of those.\par
\par
\ul\b Positional selectors\ulnone\b0\par
Often we need to locate elements based on where they are on the page, or in relation to other elements in the DOM. For example, an a element inside of a nav section may need to be treated differently than a elements elsewhere on the page. CSS, and in turn jQuery, offer the ability to find items based on their location.\par
\par
\b Parent/child relationships\b0\par
The simplest location selector is one for parent/child. The > between selectors indicates the parent/child relationship. With this relationship, the second item listed must be a direct child of the first item, with no other elements between the two.\par
\par
//Selects all a elements that are direct descendants from the nav element\par
$('nav > a')\par
\par
In the following HTML, the first element would be selected, but not the second. This is because the first link is a direct child, but the second is inside of a div element.\par
\par
<nav>\par
\tab <a href="#">(First) This will be selected</a>\par
\tab <div>\par
\tab\tab <a href="#">(Second) This will **not** be selected</a>\par
\tab </div>\par
</nav>\par
\par
\b Descendants\b0\par
To select elements where the targeted element is a descendant of another element, regardless of how many levels exist between the two, simply put a space between the two selectors.\par
\par
//Selects all a elements that are descendants from the nav element\par
//The elements can appeat anywhere inside of the element listed first\par
$('nav a')\par
\par
While the difference in syntax is subtle, it makes a big difference in regards to the items selected. Using the same HTML from above, both a elements would be selected by using the syntax $('nav a')\par
\par
<nav>\par
\tab <a href="#">(First) This will be selected</a>\par
\tab <div>\par
\tab\tab <a href="#">(Second) This will be selected</a>\par
\tab </div>\par
</nav>\par
\par
\ul\b Navigating the DOM with jQuery\par
\ulnone\b0 CSS offers quite a bit of power when it comes to selecting items. However, there are a couple of limitations. First, CSS selectors aren't dynamicl if new items are added later those new items aren't part of the selection. Second, there are times when it's just easier to express the items we want programatically rather than using CSS. Fortunately, jQuery allows us to select the items by using code as well.\par
\par
\b Parent child relationships\b0\par
jQuery offers two methods that allow the user to locate chilldren or descendants of the current selected item. Keep in mind that children will only work with direct children of the current element; anything further down the hierarchy will not be considered when using children.\par
\par
children also accepts CSS selectors. This allows you to filter children using the same syntax we covered earlier. Consider a nav element with multiple a elements as children. We may want to select all a elements that have an href starting with http://, which would indicate the link refers to an external site. We could select just those a elements by using the following syntax:\par
\par
currentElement.children('a[href^="http://"]');\par
\par
As mentioned earlier, children only applies to direct descendants. If we need to look throughout the entire hierarchy below the currently selected element, we would use the find method. find works just like children, with the only difference being that find will look beyond direct children of the current element. Just like children, find also accepts a selector for filtering.\par
\par
Consider the following HTML:\par
<nav id="navigation">\par
\tab <ul>\par
\tab\tab <li><a href="{{\field{\*\fldinst{HYPERLINK http://www.microsoft.com }}{\fldrslt{http://www.microsoft.com\ul0\cf0}}}}\f0\fs22 ">Microsoft</a></li>\par
\tab\tab <li><a href="{{\field{\*\fldinst{HYPERLINK http://www.adventure-works.com }}{\fldrslt{http://www.adventure-works.com\ul0\cf0}}}}\f0\fs22 ">AdventureWorks</a></li>\par
\tab\tab <li><a href="register">Register</a></li>\par
\tab </ul>\par
</nav>\par
\par
If we needed to select all a elements under the nav element we couldn't use children. This is where find comes into play. And, just like before, if we wanted all a elements that had an external link on the href attribute, we would use the following code:\par
\par
//selects the nav element by its ID\par
var navigation = $('#navigation');\par
\par
//selects all a elements with external link\par
navigation.find('a[href ^= "http://"]');\par
\par
\ul\b Siblings\ulnone\b0\par
Many sections of an HTML page have a consistent structure. For example, most forms will have a label, followed by an input element, followed by a placeholder for an error message.\par
\par
<div>\par
\tab <label for="name">Name: </label>\par
\tab <input type="text" id="name" />\par
\tab <div id="name-error"></div>\par
</div>\par
\par
\par
Imagine a bit of jQuery code where we had a reference to the input element, and we were performing a bit of validation. We would want to display any error message in the div element immediatly following the input tag. While we could explicitly get a reference to the div element by its id, that code wouldn't be reusable.\par
If our site maintained that structure of label, input, div, we could create generic event handlers, and update the error message simply by using that consistent structure to our advantage.\par
\par
\b Prev and next\b0\par
Here is an example of a jQuery code to grab an input element.\par
\par
var currentInput = $('name');\par
\par
To move to the prior element, jQuery provides the prev method. We can use prev() to access the prior element in the hierarchy (the label in the example). if we wanted the div element to update the error message, which follows the input element, we should use next()\par
\par
//text allows us to modify the text in an element\par
currentInput.next().text('error message');\par
\par
As with most methods used inside jQuery, both prev and next support CSS selectors.\par
\par
\b prevAll and nextAll\par
\b0 prev and next only look at the item immediately prior or after, respectively. prevAll and nextAll will select all siblings prior or after the element. Both methods also accept a CSS selector to limit the items.\par
Imagine a form with a checkbox, where upon selection we need to enable the two textboxes and labels immediately following it.\par
\par
<label for="provide-address">Provide address?</label>\par
<input type="checkbox" id="provide-address" />\par
\par
<label for="street">Street: </label>\par
<input type="text" id="street" disabled="true" />\par
\par
<label for="country">Country: </label>\par
<input type="text" id="country" disabled="true" />\par
\par
We could enable the textboxes by using the following jQuery:\par
\par
//The attr method is used ot set (or read) an attribute\par
//The first parameter is the name of the attribute, the second is the value to set\par
\par
//Since we only need input elements, we'll use the name of the tag as the filter\par
$('#provide-address').nextAll('input').attr('disabled', 'false');\par
\par
\ul Disabled attribute\ulnone : One interesting note about the disabled attribute is that it's one of the attributes that, according to the HTML specification, does not require a key/value pair. As a result, simply using <input disabled type="text"/> would disable the textbox. However, this wouldn't be a valid XML syntac. As a result, it is prefered to use either disabled="true" or disabled = "disabled" to ensure a key/value pair and well-formed XML.\par
\par
\b prevUntil and nextUntil\b0\par
Finally, prevUntil and nextUntil select all prior or following elements up to, but not including the element that matches the selector.\par
\par
\ul\b Selecting items by position\ulnone\b0\par
When creating a dynamic UI, we may not know anything else about an item other than its position. jQuery offers us the ability to both locate an item by its position in a collection, or to find out the index location of an item.\par
\par
\b Finding the index of an item\b0\par
If we have a reference to an object, but need to know where it sits in a collection of items, we can use the index method. The index method will return the zero based (ordinal) location of the item, or -1 if the item isn't found.\par
\par
var currentElement = $('some selector');\par
var parent = $('some selector');\par
var index = parent.children().index(currentElement);\par
\par
\b Finding an item by its position\b0\par
If we know the zero based (ordinal) location of an item in a collection, we can obtain a reference to that item by using the get method.\par
\par
var parent = $('some selector');\par
var element = parent.children().get(index);\par
\par
\b get return type\b0\par
One important note about get is it returns a JavaScript DOM object, not a jQuery object. This means the various jQuery methods, such as attr and text are not available. In order to call jQuery methods on the object, we must convert it to a jQuery object. Fortunately, this is just as easy as passing the object into the jQuery constructor. The above code would become:\par
\par
var parent = $('some selector');\par
var element = parent.children.get(index);\par
var jQueryObject = $(element);\par
\par
or we could just distill it into two lines:\par
var parent = $('some selector');\par
var element = $(parent.children(),get(index));\par
\par
or even to one line, if you feel like writing hateful code to your colleages:\par
var element = $($('some selector').children.get(index));\tab\par
\par
\ul\b\fs28 Getting started with DOM manipulation\ulnone\b0\par
\ul\b\fs22 Adding and removing classes\ulnone\b0\par
As we've already seen, jQuery leans on CSS syntax for quite a bit of functionality. Keeping with that theme, jQuery also makes it very easy to manipulate classes an element is currently using. In fact, we'll notice most libraries that use jQuery to manipulate the UI will also come with a stylesheet that defines a set of classes their code will use to enable the functionality.\par
\par
\b Adding a class\b0\par
Adding a class to an element is just as easy as calling addClass.\par
\par
currentElement.addClass('class-name');\par
\par
\b Removing a class\b0\par
Removing a class from an element is just as easy as calling removeClass. If the element in question was not already decorated with the class you're trying to remove, the method will simply return.\par
\par
currentElement.removeClass('class-name');\par
\par
\ul\b Working with attributes\ulnone\b0\par
As we've discussed, HTML allows us to both work with existing attributes, as well as add our own attributes as needed. This allows us to decorate elements with various flags and notes that we can use to enable functionality we desire.\par
\par
\b Retrieve an attribute value\b0\par
To retrieve an attribute value, simply use the attr method with one parameter, the name of the attribute we wish to receive\par
\par
alert($('selector').attr('attribute-name'));\par
\par
\b Modifying an attribute value\b0\par
To update an attribute value, use the attr method with two parameters, the first being the name of the attribute and the second the new value we wish to use.\par
\par
$('selector').attr('attribute-name', 'value');\par
\par
\ul\b Modifying content\ulnone\b0\par
Beyond just working with classes and attributes, jQuery also allows us to modify the content of an element as well.\par
\par
\b Updating text and HTML\b0\par
jQuery offres us the ability to update the text inside of an element by using the text method and the HTML inside of an element by using the html method. Both methods will replace the content of an element.\par
\line The main difference between the two methods is html will update (and parse) the HTML that's passed into the method, while text will be text only. If we pass markup into the text method, it will be HTML encoded, meaning all tags will be converted into the appropriate syntax to just display text, rather than markup. In other words, < will become &lt; and and just display as < in the browser. By using text when we're only expecting text, we can mitigate cross-site scripting attacks.\par
\par
\b Examples\par
\b0 //update the text\par
$(item).text('Hello, world!');\par
\par
//update the HTML\par
$(item).html('<h1>Hellow World!!');\par
\par
\ul\b Basic event handlers\ulnone\b0\par
Earlier we saw how to register an event handler for document.ready. jQuery allows us to access almost any other event that is raised via the JavaScript DOM, as well as several others. While a deeper discussion of event handlers will begin in module 2, let's take a look at a few to get us one step closer to creating real applications using JQuery.\par
\par
\b Registering event handlers\b0\par
To register an event handler, we will call the jQuery method that matches the event handler we're looking for. For example, if we wanted the click event, we'd use the click method. Methods for wiring up event handlers allow us to pass either an exxisting function, or create an anonymous method. Most developers prefer to use an anonymous metho, as it makes it easier to keep the namespace clean and not have to name another item.\par
\line Inside of the event handler code, we can access the object that raised the event by using this. One important note about this is it is not a jQuery object but rather a DOM object, we can convert it by using the jQuery constructor as we've seen before: $(this).\par
\par
\b Examples\b0\par
//click event\par
//raised when the item is clicked\par
$(item).click(function()\{\par
\tab alert('clicked!');\par
\});\par
\par
//hover event\par
//raised when the user moves their mouse over the item\par
$(item).hover(function()\{\par
\tab alert('hover!');\par
\});\par
\par
//mouseout\par
//raised when the user moves their mouse away from an item\par
$(item).mouseout(function()\{\par
\tab alert('mouse out');\par
\});\par
\par
\ul\b What happens when something isn't found\ulnone\b0\par
Imagine the following HTML:\par
<html>\par
\tab <head><title>Demo</title></head>\par
\tab <body>\par
\tab\tab <div class='blue'>Sample content</div>\par
\tab\tab\par
\tab\tab <!-- scripts go here-->\par
\tab </body>\par
</html>\par
\par
Now imagine we updated the page to add reference to jQuery, and then added the following script:\par
\par
$('blue').click(function()\{\par
\tab alert('You clicked the div element!');\par
\});\par
\par
If we ran the page and clicked on the div tag, nothing would happen.\par
This was a very simple and subtle typo, which is basically just the "." missing. Since it isn't there, the CSS selector is instructing jQuery to look for an element named blue, rather than a class named blue. Leaving off a . or # is probably the number one mistake developers make when using jQuery.\par
\par
\b But, that seems like a bad thing\b0\line At first glance, that might seem like a design flaw for jQuery. However, this can be very advantageous. In fact, we'll see this as a common pattern throughout jQuery - if it can't find an item, it will simply move to the next line of code.\par
\par
removeClass, for example, doesn't throw an error if the element in question doesn't have the class. What's nice about this is that we don't have to remember if the class was there in the first place, or write code to check for it in advance.\par
\par
While we will certainly run into cases where leaving off a . causes an unexpected bug, that behaviour will help make our code a bit simpler when we're dealing with dynamic HTML, which is exactly what jQuery is all about.\par
\par
\ul\b jQuery and DOM objects\ulnone\b0\par
When we get down to it, jQuery is a wrapper around the JavaScript DOM, both enhancing and simplifying it. One thing to remember, though, is that we are always writing JavaScript. As a result, depending on where we are in code, we might be switching back and forth between jQuery and JavaScript.\par
Let's take the following code for example:\par
\par
$('#some-button').click(function()\{\par
\tab //code here\par
\});\par
\par
As we've already discussed, we can add code to a click event by using the syntax above. And, we can access the object that raised the event. But, this is a DOM object, not a jQuery object. As a result, any of the jQuery methods we'd like to use aren't available, unless we convert it to a jQuery object by using the code below.\par
\par
var variableName = $(this);\par
\par
Obviously, that's not challenging, but it can be a bit confusing as to when the object is a jQuery object or a DOM object. More than anything, that comes with experience. The more we use jQuery, the more natural it will become. That said, one quick way to see if we have a reference to a jQuery object is to take advantage of some form of auto-complete, such as that provided thorugh IntellliSense in Visual Studio. We'd notice in Visual Studio the IntelliSense wouldn't show the different jQuery methods, which is a quick reminder that we don't have a jQuery object and need to perform the conversion.\par
\par
\ul\b jQuery's each function\ulnone\b0\par
As powerful as the selectors are in jQuery, there will still be times when you need to loop through the collection of items returned. Fortunately, jQuery does support methods such as index and get, and each collection that is returned can be accessed as an array, meaning there is a length property available. However, rather than using a traditional loop, we may decide it's easier to loop through a collection of objects using for/each.\par
\par
For/each is a common construct available in most programming environments. In a nutshell, what for/each does is instructs the runtime to grab each item in the collection, assign it to a variable that we declare, and then allow us to operate on that variable. Consider the following code:\par
\par
$('.some-class').each(function(item)\{\par
\tab //item will be a variable that will represent each object\par
\});\par
\par
in the above code, the item variable will automatically be assigned to every item in the collection. The first time through it'll be the first item, the second time the second, etc. This can be much easier than programming with a for statement.\par
The syntax for jQuery's each function is as follows:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 a collection (in the example we used a colledtion returned by a selector)\par
{\pntext\f1\'B7\tab}the each function\par
{\pntext\f1\'B7\tab}a callback function with a parameter. The name we use for the parameter will become the variable name assigned to each item in the collection\par

\pard\sl240\slmult1\par
\ul\b\fs28 Lab 1\ulnone\b0\par
\fs22 For the module 1, we will create the initial interface for our review widget. The interface must meet the following goals:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Provide five circles for the user to select or click on\par
{\pntext\f1\'B7\tab}When the user hovers their mouse over a circle, that circcle and all circles to the left must be filled with a color, such as yellow\par
{\pntext\f1\'B7\tab}When the user clicks on a circle, that circle and all circles to the left must be filles with a different color, such as green. The color must remain, even after the user moves their mouse away from the widget. We do not need to remember the number for page refreshes\par
{\pntext\f1\'B7\tab}HTML and CSS for the interface has been provided. This lab can be solved without using any additional HTML. We only need to provide the necessary jQuery\par

\pard\sl240\slmult1\par
\ul\b Tips and tricks\ulnone\b0\par
A solution will not be provided for the lab. but, to try to help us out, here are some tips we might find helpful.\par
\line First, break the requirements down to stepsm and then implement each step. For example, for the hover requirements:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 The user hovers over a circle. That circle, and all the ones to its left, must be highlighted\par
{\pntext\f1\'B7\tab}To implement this, we must first discover what circle the user has moved their mouse over\par
{\pntext\f1\'B7\tab}Then, we need to select that circle, and the ones to the left of it in the collection of circles\par
{\pntext\f1\'B7\tab}We must highlight those circles. This can be done by adding a class to those circles. The class provided is highlight\par
{\pntext\f1\'B7\tab}We must ensure the circles to the right aren't highlighted. We could do this by removing the highlight class\par

\pard\sl240\slmult1\par
\par
Some methods we might find useful:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 get\par
{\pntext\f1\'B7\tab}index\par
{\pntext\f1\'B7\tab}addClass\par
{\pntext\f1\'B7\tab}removeClass\par
{\pntext\f1\'B7\tab}attr\par
{\pntext\f1\'B7\tab}each\par
{\pntext\f1\'B7\tab}children\par
{\pntext\f1\'B7\tab}find\par

\pard\sl240\slmult1\par
Please note that not all of the methods listed above are needed for the answer.\par
\par
\ul\b\fs32 Module 2: Managing content, events and effects\ulnone\b0\par
\ul\b\fs28 Commonly used event handlers\ulnone\b0\par
\fs22 Web pages are typically built using an event based architecture. An event is something that occurs where we, as the developer, don't have direct control over its timing. Unlike the classic console application (god I miss those), where  we provide  a list of options to the user, in a time and order that we choose, a web page presents the user with a set of controls, such as buttons or textboxes, that the user can typically click around on whenever they see fit. As a result, being able to manage what happens when an event occurs is crucial.\par
\par
Fortunately, in case we hadn't already guessed, jQuery provides a robust API for registering and managing event handlers, which is the code that will be executed when an event is raised. Event handlers are, at the end of the day, simply JavaScript functions.\par
\par
\b Registering event handlers\b0\par
jQuery provides several ways to register an event handler. As we saw in Module 1, the most common way of registering an event handler is to call the function on the jQuery object that corresponds to the event we wish to capture, such as click. We will notice that the jQuery API provides functions for almost any JavaScript or DOM event.\par
\par
}
 