{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\ul\f0\fs28\lang9 jQuery Notes\ulnone\par
\b\fs22 Options for adding jQuery\b0\par
To add jQuery to a web page, it's a simple as adding a reference to the jQuery javaScript file. We always want to use the minified version, signified by min in thee name, as this will reduce the amount of data passed to the user, saving both bandwidth and loading time.\par
It is possible to download from jQuery or to use a package manager such as NuGet or npm. Similarly, we have multiple options when it comes to sourcing the JavaScript file on our page.\par
The first option is to serve the file from our own server, just as we would serve any other image or script file. Because we've already downloaded the file, it's easy to simply ensure it's part of our project, deployed to our server, and then referenced in a page. However, this is yet another file that our server has to send to the user, which increases both the number of requests that our server needs to handle and the amount of bandwidth required for the server to serve a page to the user.\par
As an alternative, we can use a content delivery network, CDN. A CDN is a set of servers hosted by a third party, such as Microsoft or Google, that hosts and serves common files used for creating web pages. In fact, most common JS libraries, including Knockout, AngularJS and Bootstrap, are available on CDNs.\par
By using a CDN we save our server from having to send down the file, the users will download the file from the CDN servers rather than ours. For heavily trafficked sites this can mean a large improvement in performance. When using popular CDN, such as the one from Microsoft, there's a good chance the user will have already downloaded the file. Browsers cache files based on path names, so if the user has visited a site that used the same file from the same CDN, the browser won't need to download that file again. As a result, the page will load that much faster.\par
\par
\b Updating our page to include a reference to jQuery\b0\par
Below is the code we'll need to add jQuery to a page. We have to keep in mind that the URL of the JavaScript file will depend on where the file is located, and if we're using a CDN.\par

\pard\sl240\slmult1 <html>\par
\tab <head>\par
\tab\tab <title>Demo page</title>\par
\tab </head>\par
\tab <body>\par
\tab\tab <script src="[location of minified jQuery JavaScript file]"></script>\par
\tab\tab <script>\par
\tab\tab\tab //our custom scripts that use jQuery\par
\tab\tab </script>\par
\tab </body>\par
</html>\par

\pard\sa200\sl276\slmult1\par
\ul\b Hello jQuery\ulnone\b0\par
Now that we've obtained jQuery, and added the approptiate library to the page, it's time to actually do something with it. As per tradition, we'll do so by doing Hello World.\par
\b The magic of the $\par
\b0 In jQuery, the $ character is the shortcut of the jQuery factory, meaning that it provides access to the jQuery object and all of the power that jQuery offers. We can use $ to access global objects and functions, and, more commonly, elements and other components in the DOM.\par
The first operation we'll typically perform in any page that uses jQuery is to register a document.ready event handler. The document.ready event handler executes after everything on the page has loaded, ensuring the entire DOM is now in memory, and the jQuery library is now available.\par
There are a coupe of ways to register this event handler. The first is to access the document object in jQuery, and register an event handler with the jQuery ready event.\par
We can use:\par

\pard\sl240\slmult1 $(document).ready(function()\{\par
\tab //code here\par
\});\par
\par
Because registering an event handler with jQuery is so common, jQuery provides a shortcut. Simply passing a function into the constructor will register that function as the event handler for document.load\par
\par
$(function()\{\par
\tab //code here\par
\});\par
\par
Both of the code blocks above are semantically identical.\par
\par
\ul\b Common CSS selectors\ulnone\b0\par
In order to start manipulating HTML page dynamically you first need to locate the desired items. One of the original goals jQuery was to use pre-existing syntax, in particular CSS selectors. CSS selectors are an expressive and powerful way of locating items based on several criteria, including element type, classes and position. By using CSS selectors we can locate any item we need on a page quickly and easily.\par
\par
jQuery offers a lot of different ways to find multiple items on an HTML page. We can use executing methods, or, more commonly, by utilising the same selector syntax that CSS offers.\par
\par
\ul Basic CSS selectors\ulnone\par
The most basic CSS selector is to simply use the name of the element we're looking for. If we want all h1 elements, we can simply use h1 as our selector.\par
\par
$('h1') //selects all h1 elements\par
\par
We'll notice, just as we saw with with document.ready, we pass the appropriate text into the jQuery constructor to indicate the selector we wish to use. Because of the flexibility of JavaScript, and how jQuery was designed, this patter stays rather constant whenever we're looking to get started using jQuery in a page - we simply need to pass the appropriate text, item, or other component into the constructor and jQuery will handle it from there.\par
\par
If we go back to the CSS selectors, we can use a class and find all the particular elements of it by simply using the name of the class with a dot in front of it, just like we would when creating a CSS stylessheet.\par
\par
And, finally, if we want to find an element by its ID, we can simply use the same CSS syntax, prepending the ID with a hash.\par
\par
After selecting multiple elements, either by calling a type of element or a class, whatever method that we call after selecting them will apply to all of the elements. For example, if we want to set up a click event handler for a group of div elements, or if we want to disable all the buttons on a page, or update a set of textboxes, we can do very easily do that inside of jQuery by calling them all together.\par
\par
\ul\b Attribute based selectors\ulnone\b0\par
The HTML specification defines many attributes, such as class and style as well as allowing developers to add their own attributes. By using CSS selector syntax, we can locate items both on custom and predifined attribtues. We can find items based on a quality for an attribute.\par
\par
To find elements in which an attribute is set to a specific value, we use the equality syntax. We must note that the value that we wish to compare must be in quotes, which means we need to use both single and double quotes to create the appropriate string. While the actual quotes we use are up to us, most JavaScript developers use single quotes for normal strings and then double quotes when they need to indicate a quoted value inside of a string.\par
\par
//select **all** elements with an attribute matching the specified value\par
$('[demo-attribute="demo-value"]')\par
\par
//selects all **h1** elements with an attribute matching the specified value\par
$('h1[demo-attribute="demo-value"]')\par
\par
\b Locating items by partial attribute values\b0\par
Many frameworks, such as Bootstrap, make their magic happen by having developers add certain classes or other attributes to their HTML. Often, the values we'll be using for classes or attributes have consistent patterns or prefixes. jQuery allows us to select items by searching inside of attribute values for desired sub-strings.\par
\par
If we wish to find all elements where the value starts with a string, we use the ^= operator:\par
$('[class^="col"]')\par
\par
If we wish to find all elements where the value contains a string, we use the *= operator:\par
$('[class*="md"]')\par
\par
There are several more operators available. We can check the documentation for a full list of those.\par
\par
\ul\b Positional selectors\ulnone\b0\par
Often we need to locate elements based on where they are on the page, or in relation to other elements in the DOM. For example, an a element inside of a nav section may need to be treated differently than a elements elsewhere on the page. CSS, and in turn jQuery, offer the ability to find items based on their location.\par
\par
\b Parent/child relationships\b0\par
The simplest location selector is one for parent/child. The > between selectors indicates the parent/child relationship. With this relationship, the second item listed must be a direct child of the first item, with no other elements between the two.\par
\par
//Selects all a elements that are direct descendants from the nav element\par
$('nav > a')\par
\par
In the following HTML, the first element would be selected, but not the second. This is because the first link is a direct child, but the second is inside of a div element.\par
\par
<nav>\par
\tab <a href="#">(First) This will be selected</a>\par
\tab <div>\par
\tab\tab <a href="#">(Second) This will **not** be selected</a>\par
\tab </div>\par
</nav>\par
\par
\b Descendants\b0\par
To select elements where the targeted element is a descendant of another element, regardless of how many levels exist between the two, simply put a space between the two selectors.\par
\par
//Selects all a elements that are descendants from the nav element\par
//The elements can appeat anywhere inside of the element listed first\par
$('nav a')\par
\par
While the difference in syntax is subtle, it makes a big difference in regards to the items selected. Using the same HTML from above, both a elements would be selected by using the syntax $('nav a')\par
\par
<nav>\par
\tab <a href="#">(First) This will be selected</a>\par
\tab <div>\par
\tab\tab <a href="#">(Second) This will be selected</a>\par
\tab </div>\par
</nav>\par
\par
\ul\b Navigating the DOM with jQuery\par
\ulnone\b0 CSS offers quite a bit of power when it comes to selecting items. However, there are a couple of limitations. First, CSS selectors aren't dynamicl if new items are added later those new items aren't part of the selection. Second, there are times when it's just easier to express the items we want programatically rather than using CSS. Fortunately, jQuery allows us to select the items by using code as well.\par
\par
\b Parent child relationships\b0\par
jQuery offers two methods that allow the user to locate chilldren or descendants of the current selected item. Keep in mind that children will only work with direct children of the current element; anything further down the hierarchy will not be considered when using children.\par
\par
children also accepts CSS selectors. This allows you to filter children using the same syntax we covered earlier. Consider a nav element with multiple a elements as children. We may want to select all a elements that have an href starting with http://, which would indicate the link refers to an external site. We could select just those a elements by using the following syntax:\par
\par
currentElement.children('a[href^="http://"]');\par
\par
As mentioned earlier, children only applies to direct descendants. If we need to look throughout the entire hierarchy below the currently selected element, we would use the find method. find works just like children, with the only difference being that find will look beyond direct children of the current element. Just like children, find also accepts a selector for filtering.\par
\par
Consider the following HTML:\par
<nav id="navigation">\par
\tab <ul>\par
\tab\tab <li><a href="{{\field{\*\fldinst{HYPERLINK http://www.microsoft.com }}{\fldrslt{http://www.microsoft.com\ul0\cf0}}}}\f0\fs22 ">Microsoft</a></li>\par
\tab\tab <li><a href="{{\field{\*\fldinst{HYPERLINK http://www.adventure-works.com }}{\fldrslt{http://www.adventure-works.com\ul0\cf0}}}}\f0\fs22 ">AdventureWorks</a></li>\par
\tab\tab <li><a href="register">Register</a></li>\par
\tab </ul>\par
</nav>\par
\par
If we needed to select all a elements under the nav element we couldn't use children. This is where find comes into play. And, just like before, if we wanted all a elements that had an external link on the href attribute, we would use the following code:\par
\par
//selects the nav element by its ID\par
var navigation = $('#navigation');\par
\par
//selects all a elements with external link\par
navigation.find('a[href ^= "http://"]');\par
\par
\ul\b Siblings\ulnone\b0\par
Many sections of an HTML page have a consistent structure. For example, most forms will have a label, followed by an input element, followed by a placeholder for an error message.\par
\par
<div>\par
\tab <label for="name">Name: </label>\par
\tab <input type="text" id="name" />\par
\tab <div id="name-error"></div>\par
</div>\par
\par
\par
Imagine a bit of jQuery code where we had a reference to the input element, and we were performing a bit of validation. We would want to display any error message in the div element immediatly following the input tag. While we could explicitly get a reference to the div element by its id, that code wouldn't be reusable.\par
If our site maintained that structure of label, input, div, we could create generic event handlers, and update the error message simply by using that consistent structure to our advantage.\par
\par
\b Prev and next\b0\par
Here is an example of a jQuery code to grab an input element.\par
\par
var currentInput = $('name');\par
\par
To move to the prior element, jQuery provides the prev method. We can use prev() to access the prior element in the hierarchy (the label in the example). if we wanted the div element to update the error message, which follows the input element, we should use next()\par
\par
//text allows us to modify the text in an element\par
currentInput.next().text('error message');\par
\par
As with most methods used inside jQuery, both prev and next support CSS selectors.\par
\par
\b prevAll and nextAll\par
\b0 prev and next only look at the item immediately prior or after, respectively. prevAll and nextAll will select all siblings prior or after the element. Both methods also accept a CSS selector to limit the items.\par
Imagine a form with a checkbox, where upon selection we need to enable the two textboxes and labels immediately following it.\par
\par
<label for="provide-address">Provide address?</label>\par
<input type="checkbox" id="provide-address" />\par
\par
<label for="street">Street: </label>\par
<input type="text" id="street" disabled="true" />\par
\par
<label for="country">Country: </label>\par
<input type="text" id="country" disabled="true" />\par
\par
We could enable the textboxes by using the following jQuery:\par
\par
//The attr method is used ot set (or read) an attribute\par
//The first parameter is the name of the attribute, the second is the value to set\par
\par
//Since we only need input elements, we'll use the name of the tag as the filter\par
$('#provide-address').nextAll('input').attr('disabled', 'false');\par
\par
\ul Disabled attribute\ulnone : One interesting note about the disabled attribute is that it's one of the attributes that, according to the HTML specification, does not require a key/value pair. As a result, simply using <input disabled type="text"/> would disable the textbox. However, this wouldn't be a valid XML syntac. As a result, it is prefered to use either disabled="true" or disabled = "disabled" to ensure a key/value pair and well-formed XML.\par
\par
\b prevUntil and nextUntil\b0\par
Finally, prevUntil and nextUntil select all prior or following elements up to, but not including the element that matches the selector.\par
\par
\ul\b Selecting items by position\ulnone\b0\par
When creating a dynamic UI, we may not know anything else about an item other than its position. jQuery offers us the ability to both locate an item by its position in a collection, or to find out the index location of an item.\par
\par
\b Finding the index of an item\b0\par
If we have a reference to an object, but need to know where it sits in a collection of items, we can use the index method. The index method will return the zero based (ordinal) location of the item, or -1 if the item isn't found.\par
\par
var currentElement = $('some selector');\par
var parent = $('some selector');\par
var index = parent.children().index(currentElement);\par
\par
\b Finding an item by its position\b0\par
If we know the zero based (ordinal) location of an item in a collection, we can obtain a reference to that item by using the get method.\par
\par
var parent = $('some selector');\par
var element = parent.children().get(index);\par
\par
\b get return type\b0\par
One important note about get is it returns a JavaScript DOM object, not a jQuery object. This means the various jQuery methods, such as attr and text are not available. In order to call jQuery methods on the object, we must convert it to a jQuery object. Fortunately, this is just as easy as passing the object into the jQuery constructor. The above code would become:\par
\par
var parent = $('some selector');\par
var element = parent.children.get(index);\par
var jQueryObject = $(element);\par
\par
or we could just distill it into two lines:\par
var parent = $('some selector');\par
var element = $(parent.children(),get(index));\par
\par
or even to one line, if you feel like writing hateful code to your colleages:\par
var element = $($('some selector').children.get(index));\tab\par
\par
\ul\b\fs28 Getting started with DOM manipulation\ulnone\b0\par
\ul\b\fs22 Adding and removing classes\ulnone\b0\par
As we've already seen, jQuery leans on CSS syntax for quite a bit of functionality. Keeping with that theme, jQuery also makes it very easy to manipulate classes an element is currently using. In fact, we'll notice most libraries that use jQuery to manipulate the UI will also come with a stylesheet that defines a set of classes their code will use to enable the functionality.\par
\par
\b Adding a class\b0\par
Adding a class to an element is just as easy as calling addClass.\par
\par
currentElement.addClass('class-name');\par
\par
\b Removing a class\b0\par
Removing a class from an element is just as easy as calling removeClass. If the element in question was not already decorated with the class you're trying to remove, the method will simply return.\par
\par
currentElement.removeClass('class-name');\par
\par
\ul\b Working with attributes\ulnone\b0\par
As we've discussed, HTML allows us to both work with existing attributes, as well as add our own attributes as needed. This allows us to decorate elements with various flags and notes that we can use to enable functionality we desire.\par
\par
\b Retrieve an attribute value\b0\par
To retrieve an attribute value, simply use the attr method with one parameter, the name of the attribute we wish to receive\par
\par
alert($('selector').attr('attribute-name'));\par
\par
\b Modifying an attribute value\b0\par
To update an attribute value, use the attr method with two parameters, the first being the name of the attribute and the second the new value we wish to use.\par
\par
$('selector').attr('attribute-name', 'value');\par
\par
\ul\b Modifying content\ulnone\b0\par
Beyond just working with classes and attributes, jQuery also allows us to modify the content of an element as well.\par
\par
\b Updating text and HTML\b0\par
jQuery offres us the ability to update the text inside of an element by using the text method and the HTML inside of an element by using the html method. Both methods will replace the content of an element.\par
\line The main difference between the two methods is html will update (and parse) the HTML that's passed into the method, while text will be text only. If we pass markup into the text method, it will be HTML encoded, meaning all tags will be converted into the appropriate syntax to just display text, rather than markup. In other words, < will become &lt; and and just display as < in the browser. By using text when we're only expecting text, we can mitigate cross-site scripting attacks.\par
\par
\b Examples\par
\b0 //update the text\par
$(item).text('Hello, world!');\par
\par
//update the HTML\par
$(item).html('<h1>Hellow World!!');\par
\par
\ul\b Basic event handlers\ulnone\b0\par
Earlier we saw how to register an event handler for document.ready. jQuery allows us to access almost any other event that is raised via the JavaScript DOM, as well as several others. While a deeper discussion of event handlers will begin in module 2, let's take a look at a few to get us one step closer to creating real applications using JQuery.\par
\par
\b Registering event handlers\b0\par
To register an event handler, we will call the jQuery method that matches the event handler we're looking for. For example, if we wanted the click event, we'd use the click method. Methods for wiring up event handlers allow us to pass either an exxisting function, or create an anonymous method. Most developers prefer to use an anonymous metho, as it makes it easier to keep the namespace clean and not have to name another item.\par
\line Inside of the event handler code, we can access the object that raised the event by using this. One important note about this is it is not a jQuery object but rather a DOM object, we can convert it by using the jQuery constructor as we've seen before: $(this).\par
\par
\b Examples\b0\par
//click event\par
//raised when the item is clicked\par
$(item).click(function()\{\par
\tab alert('clicked!');\par
\});\par
\par
//hover event\par
//raised when the user moves their mouse over the item\par
$(item).hover(function()\{\par
\tab alert('hover!');\par
\});\par
\par
//mouseout\par
//raised when the user moves their mouse away from an item\par
$(item).mouseout(function()\{\par
\tab alert('mouse out');\par
\});\par
\par
\ul\b What happens when something isn't found\ulnone\b0\par
Imagine the following HTML:\par
<html>\par
\tab <head><title>Demo</title></head>\par
\tab <body>\par
\tab\tab <div class='blue'>Sample content</div>\par
\tab\tab\par
\tab\tab <!-- scripts go here-->\par
\tab </body>\par
</html>\par
\par
Now imagine we updated the page to add reference to jQuery, and then added the following script:\par
\par
$('blue').click(function()\{\par
\tab alert('You clicked the div element!');\par
\});\par
\par
If we ran the page and clicked on the div tag, nothing would happen.\par
This was a very simple and subtle typo, which is basically just the "." missing. Since it isn't there, the CSS selector is instructing jQuery to look for an element named blue, rather than a class named blue. Leaving off a . or # is probably the number one mistake developers make when using jQuery.\par
\par
\b But, that seems like a bad thing\b0\line At first glance, that might seem like a design flaw for jQuery. However, this can be very advantageous. In fact, we'll see this as a common pattern throughout jQuery - if it can't find an item, it will simply move to the next line of code.\par
\par
removeClass, for example, doesn't throw an error if the element in question doesn't have the class. What's nice about this is that we don't have to remember if the class was there in the first place, or write code to check for it in advance.\par
\par
While we will certainly run into cases where leaving off a . causes an unexpected bug, that behaviour will help make our code a bit simpler when we're dealing with dynamic HTML, which is exactly what jQuery is all about.\par
\par
\ul\b jQuery and DOM objects\ulnone\b0\par
When we get down to it, jQuery is a wrapper around the JavaScript DOM, both enhancing and simplifying it. One thing to remember, though, is that we are always writing JavaScript. As a result, depending on where we are in code, we might be switching back and forth between jQuery and JavaScript.\par
Let's take the following code for example:\par
\par
$('#some-button').click(function()\{\par
\tab //code here\par
\});\par
\par
As we've already discussed, we can add code to a click event by using the syntax above. And, we can access the object that raised the event. But, this is a DOM object, not a jQuery object. As a result, any of the jQuery methods we'd like to use aren't available, unless we convert it to a jQuery object by using the code below.\par
\par
var variableName = $(this);\par
\par
Obviously, that's not challenging, but it can be a bit confusing as to when the object is a jQuery object or a DOM object. More than anything, that comes with experience. The more we use jQuery, the more natural it will become. That said, one quick way to see if we have a reference to a jQuery object is to take advantage of some form of auto-complete, such as that provided thorugh IntellliSense in Visual Studio. We'd notice in Visual Studio the IntelliSense wouldn't show the different jQuery methods, which is a quick reminder that we don't have a jQuery object and need to perform the conversion.\par
\par
\ul\b jQuery's each function\ulnone\b0\par
As powerful as the selectors are in jQuery, there will still be times when you need to loop through the collection of items returned. Fortunately, jQuery does support methods such as index and get, and each collection that is returned can be accessed as an array, meaning there is a length property available. However, rather than using a traditional loop, we may decide it's easier to loop through a collection of objects using for/each.\par
\par
For/each is a common construct available in most programming environments. In a nutshell, what for/each does is instructs the runtime to grab each item in the collection, assign it to a variable that we declare, and then allow us to operate on that variable. Consider the following code:\par
\par
$('.some-class').each(function(item)\{\par
\tab //item will be a variable that will represent each object\par
\});\par
\par
in the above code, the item variable will automatically be assigned to every item in the collection. The first time through it'll be the first item, the second time the second, etc. This can be much easier than programming with a for statement.\par
The syntax for jQuery's each function is as follows:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 a collection (in the example we used a colledtion returned by a selector)\par
{\pntext\f1\'B7\tab}the each function\par
{\pntext\f1\'B7\tab}a callback function with a parameter. The name we use for the parameter will become the variable name assigned to each item in the collection\par

\pard\sl240\slmult1\par
\ul\b\fs28 Lab 1\ulnone\b0\par
\fs22 For the module 1, we will create the initial interface for our review widget. The interface must meet the following goals:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Provide five circles for the user to select or click on\par
{\pntext\f1\'B7\tab}When the user hovers their mouse over a circle, that circcle and all circles to the left must be filled with a color, such as yellow\par
{\pntext\f1\'B7\tab}When the user clicks on a circle, that circle and all circles to the left must be filles with a different color, such as green. The color must remain, even after the user moves their mouse away from the widget. We do not need to remember the number for page refreshes\par
{\pntext\f1\'B7\tab}HTML and CSS for the interface has been provided. This lab can be solved without using any additional HTML. We only need to provide the necessary jQuery\par

\pard\sl240\slmult1\par
\ul\b Tips and tricks\ulnone\b0\par
A solution will not be provided for the lab. but, to try to help us out, here are some tips we might find helpful.\par
\line First, break the requirements down to stepsm and then implement each step. For example, for the hover requirements:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 The user hovers over a circle. That circle, and all the ones to its left, must be highlighted\par
{\pntext\f1\'B7\tab}To implement this, we must first discover what circle the user has moved their mouse over\par
{\pntext\f1\'B7\tab}Then, we need to select that circle, and the ones to the left of it in the collection of circles\par
{\pntext\f1\'B7\tab}We must highlight those circles. This can be done by adding a class to those circles. The class provided is highlight\par
{\pntext\f1\'B7\tab}We must ensure the circles to the right aren't highlighted. We could do this by removing the highlight class\par

\pard\sl240\slmult1\par
\par
Some methods we might find useful:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 get\par
{\pntext\f1\'B7\tab}index\par
{\pntext\f1\'B7\tab}addClass\par
{\pntext\f1\'B7\tab}removeClass\par
{\pntext\f1\'B7\tab}attr\par
{\pntext\f1\'B7\tab}each\par
{\pntext\f1\'B7\tab}children\par
{\pntext\f1\'B7\tab}find\par

\pard\sl240\slmult1\par
Please note that not all of the methods listed above are needed for the answer.\par
\par
\ul\b\fs32 Module 2: Managing content, events and effects\ulnone\b0\par
\ul\b\fs28 Commonly used event handlers\ulnone\b0\par
\fs22 Web pages are typically built using an event based architecture. An event is something that occurs where we, as the developer, don't have direct control over its timing. Unlike the classic console application (god I miss those), where  we provide  a list of options to the user, in a time and order that we choose, a web page presents the user with a set of controls, such as buttons or textboxes, that the user can typically click around on whenever they see fit. As a result, being able to manage what happens when an event occurs is crucial.\par
\par
Fortunately, in case we hadn't already guessed, jQuery provides a robust API for registering and managing event handlers, which is the code that will be executed when an event is raised. Event handlers are, at the end of the day, simply JavaScript functions.\par
\par
\b Registering event handlers\b0\par
jQuery provides several ways to register an event handler. As we saw in Module 1, the most common way of registering an event handler is to call the function on the jQuery object that corresponds to the event we wish to capture, such as click. We will notice that the jQuery API provides functions for almost any JavaScript or DOM event.\par
\par
We will discuss many of these event handlers as we continue on this course, but we won't cover every function available - that would take quite a while, and probably bore almost everyone. But we will cover the ones we'll use most frequently. In addtion, we'll also cover the various ways we can register an event handler, which will have an impact on the way we write our code in many scenarios.\par
\par
\ul\b Event object\ulnone\b0\par
When we register an event handler from a location other than the object that will be raising the event, there's a disconnect between those two objects. If we're maintaining a 1:1 ratio between event handlers and events, meaning that each event that we're interested in has its own function, then generally there isn't an issue in assuming we know exactly what happened, and on what object it happened to.\par
\par
However, even if we are maintaining that 1:1 ratio, that can be a brittle relationship. if something changes on the object, the code might not work with the updates that have been made.\par
\par
In addition, we will often reuse a single event handler for multiple events. The power of the selector syntax supported in jQuery allows us to wire up event handlers for events raised by many controls in one line of code. The code below would register the anonymous function with every element decorated with the sample class. The number of elements with that class couls change over the course of the page's development, or even the execution of other scripts.\par
$('.sample').click(function()\{alert('Hello!');\});\par
\par
When creating event handlers, it's often best not to make any assumptions about the object that raised the event, even its ID. Not only can things change that might break our code, if we avoid this link between the event handler and the object our code can become both more reusable and flexible.\par
\par
\b this\b0\par
As we've already discussed, when we're inside of an event handler, this is automatically assigned to the object that raised the event.\par
\par
The most important thing to remember about this is it will be a DOM object and not a jQuery object. This means all of the power jQuery provides won't be available directly off this. in order to use jQuery with the object, it needs to be converted to a jQuery object. This is accomplished by simply calling $(this).\par
\par
The sample below would update the text of the button that was clicked to Clicked!!\par
<button type="button">Click!</button>\par
$('button').click(function()\{\par
\tab //this is linked to button that was clicked, but it is a DOM object\par
\tab //convert it to a jQuery object by using jQuery factory\par
\tab $(this).text('Clicked!');\par
\});\par
\par
\b event object\b0\par
Beyond just the object that raised the event, jQuery (and JavaScript) also pass an event object to the event handler. This object can be used to determine additional information, such as where the mouse was when the user performed the operation. We might use the information to create hotspots on an element. The event object offers many properties we can query.\par
//Write out the x/y coordinates of the mouse click\par
$('button').click(function(e) \{\par
\tab $('#output').text(e.pageX + ',' + e.pageY);\par
\});\par
\par
\ul\b Click\ulnone\b0\par
jQuery allows us to use functions to wire up event handlers to most every JavaScript or DOM event. Here are some of the most common ones we'll use when creating code using jQuery\par
\par
\b click\b0\par
By far, the most common event handler is click. click, of course, is raised whenever the user clicks on an item, either by using their mouse or tapping on it with their finger. We can register click for nearly any HTML control, not just buttons. This allows us to "convert" other objects, such as div elements, into buttons. We can use this to provide the rich UI we want without being locked into using specific HTML controls, or essentially create our own controls.\par
\par
To register the click event, we simply have to use the click function.\par
\par
\b dblclick\b0\par
As the name implies, dblclick is raised when the user double clicks on an element. The dblclick event can be helpful when creating an application that is designed to behave more like a locally installed app. However, if we're going to use the dblclick event, we have to ensure the user knows to double click on items.; that's not a common task on a web page.\par
It is used the same way the click method is used.\par
\par
\ul\b Forms\ulnone\b0\par
\par
\b blur\b0\par
The blur event is raised when a form element loses what's known as focus. This simply means the user has clicked elsewhere on the page or as tabbed away from the form control they were on. blur is often used for validation, as we know the user has left the form field. While this was originally designed for input fields, many modern browsers allow the blur event to be raised for any element type.\par
\par
To register a handler with the blur event, we can simply call the blur function:\par
$('#target').blur(function()\{\par
\tab //retrieve the value using val\par
\tab var value = $('#target').val();\par
\tab alert(value);\par
\});\par
\par
\b change\b0\par
The change event is raised whenever an element is modified. However, the change event is limite to input, textarea and select elements only.\par
\par
Besides just validation, the change event can be used to create interfaces such as cascading dropdown lists. If the list of available values for one dropdown list depends on the selected value of another, change is perfect for that. We would register the event handler on the parent, and when it changes update the child dropdown list. Using the following HTML:\par
\par
<style>\par
\tab .form-control\{\par
\tab\tab font-family: Verdana;\par
\tab\tab font-size: 16px;\par
\tab\}\par
</style>\par
\par
<select id="parent" class="form-control">\par
\tab <option>Select:</option>\par
\tab <option>First</option>\par
\tab <option>Second</option>\par
</select>\par
\par
<select id="child" class="form-control">\par
\tab <option>Choose a value from the left</option>\par
</select>\par
\par
We will use the following code to update the child:\par
$(function()\{\par
\tab $('#parent').change(function()\{\par
\tab\tab var value = $('#parent').val();\par
\tab\tab $('#child').empty();\par
\tab\tab $('#child').append('<option>1 - ' + value + '</option>');\par
\tab\tab $('#child').append('<option>2 - ' + value + '</option>');\par
\tab\});\par
\});\par
\par
\b focus\b0\par
focus is essentially the opposite of blur. focus is raised when the user clicks, taps, or tabs into a particular control, typically because they want to change its value. We can use focus to provide inline help for a form, such as letting the user know what format you expect for a phone number. This is demostrated below.\par
\par
One thing to note is we have the ability to "chain" registrations and other calls when using jQuery. Many jQuery functions return the object we originally accessed (the element with the id phone below). As a result, we can simply call blur right after calling focus.\par
\par
<!-- sample HTML -->\par
<div>\par
\tab <label for="phone">Phone</label>\par
\tab <input type="text" id="phone" />\par
\tab <span id="phone-help"></span>\par
</div>\par
\par
//sample JavaScript\par
$('#phone').focus(function()\{\par
\tab //control has focus. Display help\par
\tab $('#phone-help').text('Please enter your phone number as all digits');\par
\}).blur(function()\{\par
\tab //control lost focus. Clear help\par
\tab $('#phone-help').attr('disabled', 'true');\par
\});\par
\par
\ul\b Mouse mouvement\ulnone\b0\par
\b mouseenter and mouseleave\b0\par
mouseenter is raised whenever the user moves their mouse over an element, and mouseleave is raised when the user moves their mouse away from an element. We might use this to provide a tooltip or other contextual information.\par
\par
<!-- sample HTML -->\par
<div>\par
\tab <span id="target">Basic data</span>\par
\tab <span id="target-help"></span>\par
</div>\par
\par
//sample JavaScript\par
$('#target').mouseenter(function()\{\par
\tab $('#target-help').text('More data');\par
\}).mouseleave(function()\{\par
\tab $('#target-help').text('');\par
\});\par
\par
\b hover\par
\b0 The hover event is logically equivalent to both the mouseenter and mouseleave events. What makes hover special is you can actually register two event handlers in one call. The first parameter hover accepts is for mouseenter, or when the hover begins, and the second parameter is for mouseout. The code below is the equivalent of the one above:\par
$('#target').hover(function()\{\par
\tab $('#target-help').text('More data');\par
\}, function()\{\par
\tab $('#target-help').text('');\par
\});\par
\par
\ul\b\fs28 Modifying elements\ulnone\b0\par
\ul\b\fs22 Replacing element HTML and text\ulnone\b0\par
We've always had the ability to modify the DOM using JavaScript. Where jQuery comes into play is in how it eases the process. As we've seen, jQuery makes it easier to select items, and handles cross browser support for us. This allows us to focus more attention on building the UI for our users, and implement the necessary logic, and less time on how to make the page behave the way we want.\par
\par
In this section, we'll talk about some of the functions jQuery offers for accessing and replacing the values of elements, attributes and CSS. Some of this was introduced in Module 1, but there are a few new features we'll introduce here.\par
\par
\b val\b0\par
If we wish to retrieve the value of an input control, all we have to do is call val().\par
\par
var value = $('#some-input-control').val();\par
If we wish to set the value, simply pass the new value in as a parameter to the val function. If we wish to set a textbox to a blank value, we simply have to use an empty string.\par
\par
\b html and text\b0\par
The two must basic functions for working with the content of an element are text and html. Both functions will return the entire contents of the element (if called without a parameter), or replace the entire contents with the parameter we provide. The difference between the two is encoding.\par
\par
If we use text, all special HTML characters, such as < and >, will be replaced with their encoded equivalents. This can be helpful when working with data from an untrusted source as it will not be written out to the page as HTML.\par
\par
\ul\b Working with attribute and classes\ulnone\b0\par
To work with an manipulate attributes, jQuery provides the attr function. Among the many overloads of the function, the two most common are the ones that take one or two parameters.\par
\par
If we need to retrieve the value of an attribute, we can do this by simply calling attr(name). To change the value of an attribute, we simply have to call attr('name', 'attributeValue').\par
\par
Even special attributes such as id, name and class are attributes, and can be both accessed and updated using the exact same syntax. However, certain attributes, like class and style have functions all of their own.\par
\par
\b Working with classes\b0\par
When we're updating a UI the simplest, and most common, way of making changes is thorugh CSS classes. To assist us, jQuery provides addClass and removeClass. As we might expect, addClass will add the class we provide as a parameter and removeClass will remove it.\par
\par
One nice thing about removeClass is it will not throw an error if the class doesn't exist. As a result, if we know we don't want a class, but don't know if it's currently being applies, we can simply call removeClass knowing the code won't fail.\par
\par
\ul\b Working with styles\ulnone\b0\par
As a general rule, if we want to adjust the style of an element the best way to do this is through classes. By working with classes, we gain the ability to reuse that style in other places. In addition, we separate the style from the code, which allows us to easily change the style as needed without having to update the JavaScript.\par
\par
But we may still find ourselves needing to modify the CSS of an element directly. If this is the case, we could manipulate an item's style by simply using attr.\par
$('#target').attr('style', 'color: red');\par
\par
That would work, but it's not ideal. We also have to remember that attr is going to replace the style attribute, not update it, so any existing styles would be lost. Trying to add or remove styles using attr becomes a challenge.\par
\par
Setting styles is simply a matter of setting a bunch of property/value pairs. Because of that fact, jQuery exposes an item's style as these pairs through a special function, css.\par
\par
css will parse an item's style property as the set of key value pairs, allowing us to both read and write each property individually.\par
If we want to retrieve the value of a CSS property, we call css(property)\par
var color: $('#target').css('color');\par
\par
If we wish to set a property,  we have to call css(property, newValue)\par
$('#target').css('color', 'red')\par
\par
If we want to set multiple properties, we can create a JavaScript object with the property/value pairs, and then pass the object into the css function. We can create an object like we would create a normal JavaScript object.\par
\line The catch, of course, is properties like background-color. Obviously, JavaScript can't work with a hyphen in a name. We could create an object with that property by either using camel casing like \{backgroundColor: 'red'\} ,or set the property names as strings. The end result of the JavaScript would be an element with red text and a yellow background.\par
\par
var style = \{\par
\tab color: 'red',\par
\tab backgroundColor: yellow\par
\};\par
\par
$('#target').css(style);\par
\par
\ul\b\fs28 Registering event handlers\ulnone\b0\par
\ul\b\fs22 Dynamic Event handlers\ulnone\b0\par
Chances are, when we're creating event handlers, we'll use the function that matches the event the vast majority of the time. After all, it's straight forward to type out, and later read, $('selector').click(function() \{\}); when we're comfortable with jQuery. But this approach does have only drawback: the only event we're going to register with that syntax is click. What happens if we want to be able to register the same event handler for multiple events? Or what about a scenario where we need to determine the event based on something else that happens on the screen - maybe changing mouseenter to click?\par
\par
With on and off, we can register and unregister event handlers, respectively, while passing in the name of the event, or events, as a string.\par
\par
\b on and off\b0\par
Both on and off share the same syntax:\par
$('selector').on/off('events', 'selector (optional)', function)\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 events: a space separated list of the events we wish to register such as 'click' or 'mouseenter click'\par
{\pntext\f0 2.\tab}selector (optional): an optional selector. we will discuss this in the next unit\par
{\pntext\f0 3.\tab}function: the function we wish to call. As per usual, this can be either a regular function or, typically, an anonymous function.\par

\pard\sl240\slmult1\par
\b Which on should we use?\par
\b0 Often the choice between using click(function() \{\}) or on('click', function()\{\}) is a matter of personal preference. If we need, however, to dynamically choose the event, or if we need multiple events for the same event handler, using on is our only choice. In addition, on offers one more feature, known as delegation which we'll explore in the next chapter.\par
\par
\ul\b Delegation\b0\par
\ulnone One of the concepts we'll explore later is the power jQuery offers developers for modifying the DOM programatically. We can easily add buttons, div elements, etc., as needed.\par
\par
The question then becomes, what would happen in the following scenario?\par
\par
<button>Click</button>\par
<div id="placeholder"></div>\par
\par
$(function()\{\par
\tab //document.ready (on load event)\par
\par
\tab //register a click event handler with all button elements\par
\tab $('button').click(function() \{ alert('hello'); \});\par
\par
\tab //create a new button\par
\tab $('#placeholder').html('<button>New button</button>');\par
\});\par
\par
When the JavaScript code executes, a new button will be created after we registered an event handler for all buttons. Does the new button get the same click event handler?\par
\par
\b Introducing delegate\b0\par
In order for click, or, in some cases, on, to work, the element must be already on the page. As a result, if we registered an event handler, and later created a new element that would match the selector we used, the event handler wouldn't apply.\par
\par
Enter delegate. Registering an event handler using delegate, as demosntrated, is similar to on, with one major difference: New elements, will automatically have the event handler applied.\par
\par
Using the above example, if we updated the click event handler registration to the new code below, both the existing button and new button would have the same event handler.\par
\par
$(document).delegate('button', 'click', function()\{ alert('hello'); \});\par
The delegate syntax is $(selector).delegate(selector, events, eventHandler)\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 $(selector): in order to use delegate, the jQuery factory must return a parent of the object we wish to wire up\par
{\pntext\f0 2.\tab}selector: From the parent, we need to provide a selector to retrieve the necessary elements\par
{\pntext\f0 3.\tab}events: Same events string as before\par
{\pntext\f0 4.\tab}eventHandler: Same event handler function as before\par

\pard\sl240\slmult1\par
One important note about using delegate is we are required to start at a parent object, rather than at the object itself. For example, in the scenario proposed above, we want to register the same click event handler for all buttons. Normally the selector would be 'button'. But, delegate requires we start at a parent, and then the selector we provide as the first parameter will locate the elements from that parent. Since we want all buttons, we can use document, which will give us the entire document.\par
\par
\b Delegating event handlers with on\b0\par
With jQuery 1.7, delegate is superseded by on. As we've seen in the prior unit, on had a selector parameter as well. If we do not provide that selector, on behaves like a normal event handler registration. But, if we do provide a selector, it will use delegation to register the event handlers.\par
\par
One important thing to note is the order of parameters for on and delegate. With on, we list the events first and the selector second. With delegate, it's selector followed by events.\par
\par
\ul\b Single execution\ulnone\b0\par
When we register an event handler with an object, that event handler will remain with that object until we unregister it, which we could do with a function such as off.\par
\line However, what if we know in advance we only want the ecent to execute once? For instance, if we're creating a button that will submit a form, we only want the user to click the button once. With jQuery, we can avoid the user from submitting a form more than once by indicating that the event should only execute once.\par
\par
\b one\b0\par
one shares a similar syntax with on, only there is no delegation option, We simply provide the name of the event, and the event handler.\par
\par
<button id="single">This only works once</button>\par
<div id="output"></div>\par
\par
$(function()\{\par
\tab $('#single').one('click', function()\{\par
\tab\tab $('#output').text('You clicked on the button');\par
\tab\});\par
\});\par
\par
\ul\b Triggering events\ulnone\b0\par
Typically events are raised by the user performing the action themselves. But there may be scenarios where we may want to raise the event progamatically. For example, we may want to allow a user to click on a button to refresh data, or perform the operation on your own through code. jQuery allows us to raise events through one of three methods, either the registration method, such as click, or one or two trigger methods: trigger or triggerHandler.\par
\par
\b Helper method\b0\par
The easiest method to use to trigger an event is simply call the registration function without any parameters. For example, $('#demo').mouseenter() will automatically perform the mouseenter event for the element with an id of demo.\par
\par
\b trigger and triggerHandler\b0\par
Using a similar syntax to on, trigger and triggerHandler allow us to provode the name of the event as a parameter. The difference between the two is trigger will execute for all elements in the collection, while triggerHandler only executes the handler for the first element.\par
\par
<button type="button" id="first">First button</button>\par
<button type="button" id="Second">Second button</button>\par
<button type="button" id="trigger">trigger</button>\par
<button type="button" id="trigger-handler">triggerHandler</button>\par
\par
$(function()\{\par
\tab $('button').click(function()\{\par
\tab\tab //display the id of the button\par
\tab\tab alert(this.id);\par
\tab\});\par
\par
\tab $('#trigger').click(function()\{\par
\tab\tab //would alert every button's id\par
\tab\tab //including the last two\par
\tab\tab $('button').trigger('click');\par
\tab\});\par
\par
\tab $('#trigger-handler').click(function()\{\par
\tab\tab //would alert "first"\par
\tab\tab $('button').triggerHandler('click');\par
\tab\});\par
\});\par
\par
\ul\b\fs28 Adding new elements\ulnone\b0\par
\ul\b\fs22 Manipulating the DOM\ulnone\b0\par
As we've already seen, html and text can be used to update the page. The problem with those functions, however, is those functions replace the contents of the element they're called on, rather than modifying the content. We could keep appending text, but after a while our code would fall under its own weight. jQuery offers several functinos to easily manipulate the DOM.\par
\par
\b Internal DOM manipulation\b0\par
If we wish to update the contents of an element by adding or removing elements, we can use append, appendTo, prepend and prependTo. We must however remember that the element we target will become the container for the new element. So using append will add a new element inside the target, not after the element.\par
\par
\b prepend and prependTo\b0\par
prepend and prependo add new content to the begining of the contents of a target. The difference between them is the order in which the parameters and target are passed in. The lines of code below are semantically identical.\par
\par
//prepend is called on the target, and accepts the new content as a parameter\par
$('#target#).prepend('<div>New content</div>');\par
\par
//prependTo is called on the new content, and acceepts the target as the parameter\par
$('<div>New content</div>').prependTo('#target');\par
\par
If we had the following starting HTML:\par
<div id="target">\par
\tab <div>existing content</div>\par
</div>\par
\par
And executed either of the lines of JavaScript above, the result would be as follows:\par
<div id="target">\par
\tab <div>New content</div>\par
\tab <div>existing content</div>\par
</div>\par
\par
\b append and appendTo\b0\par
append and appendTo add new content to the end of the contents of a target. The difference between them is the order in which the parameters and target are passed in. The lines of code below are semantically identical.\par
\par
//append is called on the target, and accepts the new content as a parameter\par
$('#target').append('<div>New content</div>');\par
\par
//appendTo is called on the new content, and accepts the target as a parameter\par
$('<div>New content</div>').appendTo('#target');\par
\par
\ul\b External DOM manipulation\ulnone\b0\par
Functions such as prependd add new content inside the target, using the target as a container for the new content. If we wish to add new content before or after an existing element, jQuery provides after, insertAfter, before and insertBefore.\par
\par
\b after and insertAfter\b0\par
after and insertAfteer both add new content after the target, on the same level of the hierarchy, rather then inside the target. The difference between the two functions is the order of parameters and target. After id calles on the target, and accepts the new content as a parameter, whilst insertAfter is called on the new content, and accepts the target as a parameter. Using after to create some content:\par
$('#target').after('New content');\par
\par
If we had the following HTML as the starting point:\par
<div id="target">\par
\tab <div>existing content</div>\par
</div>\par
\par
After calling the function, the result would be the following:\par

\pard\sl240\slmult1 <div id="target">\par
\tab <div>existing content</div>\par
</div>\par

\pard\sl240\slmult1 <div>New content</div>\par
\par
\b before and insertBefore\b0\par
before and insertBefore both add new content before the target, on the same level of the hierarchy, rather than inside the target, The difference between the two functions is the order of parameters and target. before is called on the target, and accepts the new content as a parameter, whilst insertBefore is called on the new content, and accepts the target as a parameter\par
\par
Using $('#target').before('New content'); on the previous starting HTML would result in:\par
<div>New content</div>\par

\pard\sl240\slmult1 <div id="target">\par
\tab <div>existing content</div>\par
</div>\par

\pard\sl240\slmult1\par
\ul\b Wrapping content\ulnone\b0\par
The will be times we'll need to manipulate the DOM by surrounding existing content with a new element. jQuery provides several wrapping functions to perform that type of an operation.\par
\par
\b wrapping functions\b0\par
For the wrap and wrapAll demonstrations below, we'll be using this HTML as the starting point:\par
<div id="target">\par
\tab <div class="demo">Item one</div>\par
\tab <div class="demo">Item two</div>\par
</div>\par
\par
\b wrap\b0\par
The wrap function wraps each item with the element passed into the function. As a result, if we called $('#target').wrap('<section></section>'); the result would be:\par
<section>\par
\tab <div id="target">\par
\tab\tab <div class="demo">Item one</div>\par
\tab\tab <div class="demo">Item two</div>\par
\tab </div>\par
</section>\par
\par
Where things get a little more interesting is if we used a selector that returned multiple items. Imagine the following JavaScript:\par
$('.demo').wrap('<section></section>');\par
\par
The result would be:\par
<div id="target">\par
\tab <section>\par
\tab\tab <div class="demo">Item one</div>\par
\tab </section>\par
\tab <section>\par
\tab\tab <div class="demo">Item two</div>\par
\tab </section>\par
</div>\par
\par
We have to notice that wrap will wrap each element returned by the selector with the new element.\par
\par
\b wrapAll\b0\par
wrapAll behaves differently. Rather then wrapping each returned element, wrapAll wraps all returned content with one new element. As a result, the JavaScript $('#demo').wrapAll('<section></section>'); will result in:\par
<div id="target">\par
\tab <section>\par
\tab\tab <div class="demo">Item one</div>\line\tab\tab <div class="demo">Item two</div>\par
\tab </section>\par
</div>\par
\par
\b wrapInner\b0\par
wrapInner is different from both wrap and wrapAll in that wrapInner operates on the children of the target, rather than on the target itself. If we started with the following HTML:\par
<div id="target">\par
\tab <div>Item one</div>\par
\tab <div>Item two</div>\par
</div>\par
\par
and executed the JavaScript below:\par
$('#target').wrapInner('<section></section>');\par
\par
the result would be:\par
<div id="target">\par
\tab <section>\par
\tab\tab <div>Item one</div>\par
\tab\tab <div>Item two</div>\par
\tab </section>\par
</div>\par
\par
\ul\b\fs28 Animations\ulnone\b0\par
\ul\b\fs22 Introducing Animations\ulnone\b0\par
Up until now, whenever we've manipulated the DOM the results have just appeared. While this is just fine, ir can sometimes be a bit jarring to the user. It would certainly be nice if we could have just a little animation, to either make our page look more professional, or to draw the user's attention to the new or updated content\par
\par
\b hide, show and toggle\b0\par
jQuery offers many animations. The first two are hide and show. As we may suspect, hide causes something to disappear from the screen, while show causes something to appear. toggle, on the other hand, determines the current status of the item in question and changes it. So if the item was currently hidden, toggle would call show, and if the item was visible, toggle would call hide.\par
\par
Behind the scenes, jQuery controls visibility by using the display property in CSS. When we hide an item, jQuery will store the current value of display (such as inline or block) and then set the display to none. When we call show, jQuery resets the display CSS property back to the value it had stored before.\par
\par
hide, show and toggle all take several parameters, including a set of options that allow us to control things like "easing", which is how the animation is going to take place. Most commonly the only parameter we will provide is the duration we wish the animation to take place over, in milliseconds.\par
\par
<div id="target">Show or hide</div>\par
<button type="button" id="btn-toggle">Toggle</button>\par
\par
$(function()\{\par
\tab $('#btn-toggle').click(function()\{\par
\tab\tab //animation wil take on second (slow af)\par
\tab\tab $('#target').toggle(1000);\par
\tab\});\par
\});\par
\par
One final note about this, and all animations. Animations in jQuery return a promise object, which can be used to run code after an animation completes. We'll discusse promises in Module 3.\par
\par
\ul\b Animations in action\ulnone\b0\par
In the prior demonstrations and videos, we saw how to use show, hide and toggle to easily modify the visibility of an item, while also adding a little bit of animation to the UI. While this is certainly a neat trick, there's a very good change we'll want to start a UI with a section already hidden.  Using the following scenarion:\par
<form>\par
\tab <div>\par
\tab\tab <label>Name: </label>\par
\tab\tab <input type="text"/>\par
\tab </div>\par
\tab <div>\par
\tab\tab <label>Additional information:</label>\par
\tab\tab <input type="text"/>\par
\tab </div>\par
</form>\par
\par
In the above form, we want to prompt the user for their name, and additional information. But what happens if that additional information is optional? It would be nice to provide some form of a button, checkbox, or otherwise, to enable the user to display the additional information section, rather than always displaying it.\par
\par
Or, imagine if we were building a page where we had additional details, maybe a user agreement, that many people will ignore. Displaying that on the page takes up unnecessary real estate.\par
\par
In both of those scenarions, it'd be great if we could hide the item, and only if the user indicates they want to see the extra data should we show it to them.\par
We can accomplish this by starting with the following HTML, updated from before:\par
<style>\par
\tab .hidden\{ display: none;\}\par
</style>\par
<form>\par
\tab <div>\par
\tab\tab <label>Name: </label>\par
\tab\tab <input type= "text"/>\par
\tab </div>\par
\tab <button type="button" id="show-additional-information">Show additional information</button>\par
\tab <div id="additional-information" class="hidden">\par
\tab\tab <label>Additional information: </label>\par
\tab\tab <input type="text"/>\par
\tab </div>\par
</form>\par
\par
and then we would add the following script to it:\par
$(function()\{\par
\tab $('#show-additional-information').click(function()\{\par
\tab\tab $('#additional-information').show(750);\par
\tab\});\par
\});\par
\par
We'll notice that we're setting the div element wirh additional-information as its ID to display:none to start. This display property is what show will modify. We're then setting up the click event handler to call show, which will then cause the item to display.\par
\par
\ul\b Fading and sliding\ulnone\b0\par
Both show and hide have a vertical animation. The new content sort of "rolls" onto the screen, or "rolls" up from the screen. If we don't want that additional animation, and just want the item to slowly appear or disappear, we can use fading.\par
\par
\b fadeIn, fadeOut and fadeToggle\b0\par
Like their show/hdie counterparts, fadeIn and fadeOut will display and hide an item respectively. And, like toggle, fadeToggle will reverse the current state of the item.\par
\par
The fading functions perform their work by both  modifying the CSS display property, and animates the item by modifying its opacity. If we want an item to start as hidden by default, and display using fadeIn, we only need to set display: none; and there is no need to modify the starting opacity.\par
\par
Like all animation functoins, the fading functions accept various parameters with the most common being the length of time (in milliseconds). Also, the fading functions return a promise, which we'll explore in Module 3.\par
\par
\b Sliding\b0\par
Unlike the other animations, the sliding functions cause the entire item to either slide down or slide up.\par
Keeping with the conventions we've already seen, slideDown will cause the item to appear, slideUp will cause it to disappear, and slideToggle will cause change to its state.\par
\par
The sliding functoins perform their work by both modifying the CSS display property, and animates the item by modifying its position. If we want an item to start as hidden by default, and display it by using slideDown, we only need to set display:none; and there's no need to modify the starting position.\par
\line Like all animation functions, the sliding functoins accept various parameters with the most common being the length of time. Also, these functions also return a promise.\par
\par
\ul\b\fs28 Removing , replacing and cloning\ulnone\par
\ul\fs22 Removing and replacing items\ulnone\b0\par
Besides just creating new content, there will be times when we want to remove existing content, or replace content with new content. As we might have guessed, jQuery offers us the power as well.\par
\par
\b remove and empty\b0\par
Both remove and empty completely delete items from the DOM. The difference between the two is what they delete. In the case of remove, it will delete the item we target, while empty deletes the content of the item we target.\par
\par
Considering the following HTML:\par
<div id="target">\par
\tab <div>Some cool content</div>\par
\tab <div>Some more cool content</div>\par
</div>\par
\line If we called $('#target').remove, the resulting HTML would be nothing. The entire contents of the sample are removed.\par
\line Contrasting that will calling $('#target').empty(), empty would delete the contents of the target, so the resulting HTML would be:\par
<div id="target">\par
</div>\par
\par
\b replaceAll and replaceWith\b0\par
If we wish to replace existing content with new content, jQuery offers replaceAll and replaceWith. In both cases, we'll provide what existing content we wish to replace, and what new content we wish to use. The difference between the two is the order in which we pass existing and new content.\par
\par
If we had the following starting HTML:\par
<div id="target">\par
\tab <div>Some cool content</div>\par
\tab <div>Some more cool content</div>\par
</div>\par
\par
and wanted to finish with the following HTML:\par
<div>NEW content</div>\par
then either method below would work:\par
\par
//replaceWith replaces the content on the left with the content in the parameter\par
$('#target').replaceWith('<div>NEW content</div>');\par
\par
//replaceAll replaces the target in the parameter with the content on the left\par
$('<div>NEW content</div>').replaceAll('#target');\par
\par
When using either replaceAll or replaceWith, the entire element is replaced, not just the contents of the element. This functions are to be used with caution.\par
\par
\ul\b Cloning\ulnone\b0\par
The main reason to use jQuery is because it makes "day to day" programming in JavaScript much easier, offering functionality and capabilities common to other programming environments. Because the basic operations become that much easier, it allows us to focus our attention on the cooler features we wish to add to our pages, adding interactivity, and making our page seem more like a locally installed application.\par
\par
This is where the humble function clone comes into play. clone allows us to make a copy of jQuery objects.\par
\par
\b clone in the real world\b0\par
There are several scenarios in which clone simplifies content creation. Let's say we're building a page to allow an administrator to create email addresses and passwords. We'd like to ensure the administrator can create as many accounts as they would like on one page, and be able to send up all the information to the server in one round trip, rather than using Ajax calls or submitting the form for each account.\par
\line This requires the ability to dynamically add labels and textboxes. We could do that this way:\par
<button type="button" id="add-line>Add new line</button>\par
<div id="container">\par
\tab <div class="user-entry">\par
\tab\tab <label>Email: </label>\par
\tab\tab <input type="email"/>\par
\tab\tab <label>Password</label>\par
\tab\tab <input type="password"/>\par
\tab </div>\par
</div>\par
\par
$(function()\{\par
\tab $('#add-line').click(function()\{\par
\tab\tab $('#container').append('<div class="user-entry"> <label>Email: </label> <input type="email"/> <label>Password: </label> <input type="password"/> </div>');\par
\tab\});\par
\});\par
\par
It would work. But we've got a large string literal in JavaScript, which can be tough to debug when we got to make changes. In addition, whatever tool we're using to create our page isn't going to be able to offer us any support for the HTML that's inside of the string literal. And finally, we have the same markup twice, both in the starting HTML and in the JavaScript. (Granted, we could clean that up by adding the first line in through JavaScript, but that's not really the best solution here).\par
\par
A better way to solve this problem would be to clone the starting HTML that makes up the user information form, and then use that clone to add the new content:\par
$(function()\{\par
\tab $userForm = $('.user-entry').clone;\par
\tab $('#add-line').click(function() \{\par
\tab\tab $('#container').append($userForm.clone());\par
\tab\});\par
\});\par
\line Let's break down the code just a bit here. For starters, we'll notice on line 2 that we are grabbing a clone of the item with the class of user-entry. This contains the form for inputting the user. We'll also notice we use a variable that starts with $. This is common in jQuery to indicate the object is a jQuery object.\par
\par
On line 4, we'll notice we use the $userForm in append to add the markup (or jQuery object) we copied earlier. What we'll also notice is that we're calling clone a second time. The reason for this is how JavaScript passes parameters. When we're working with an object, JavaScript passes a reference to the object, not a copy of the object. This would mean that we've added in a pointer to the clone we created earlier, not a brand new copy. The end result is that if we did not call clone() a second time, we'd be trying to add the exact same object into the container again, not a brand new copy. By calling clone() again on line 4, we pass in a copy of our user form, rather than a pointer to one we already used.\par
\par
\ul\b Combining cloning and animations\ulnone\b0\par
Now that we knwo how to clone items to simplify creation of dynamic content, and how to animate them to add some punch to our pages, let's see how we could bring it all together.\par
In the cloning section, we had the following demo HTML:\par
<button type="button" id="add-line">Add new line</button>\par
<div id="container">\par
\tab <div class="user-entry">\par
\tab\tab <label>Email: </label>\par
\tab\tab <input type="email"/>\par
\tab\tab <label>Password: </label>\par
\tab\tab <input type="password"/>\par
\tab </div>\par
</div>\par
\par
and the following JavaScript:\par
$(function()\{\par
\tab $userForm = $('.user-entry').clone();\par
\tab $('#add-line').click(function()\{\par
\tab\tab $('#container').append($userForm.clone());\par
\tab\});\par
\});\par
\line Let's modify our code to provide animation to the new elements. We'll start making sure our cloned item is hidden by using the css function. Because $userForm is a jQuery object, we can manipulate it just like any other jQuery object.\par
\par
//insert after line 2\par
$userForm.css('display', 'none');\par
\par
When we call append, we know that the new item is going to be the last element in the container. We can access container's children by using children and access the last one by calling last.\par
\par
We also know that the item is hidden, because we set it to be hidden. If we call show, it will then display, with the animation. We can accomplish this by cloning it into a variable, adding the new variable, and then calling show on the new variable.\par
\par
//Replace line 4\par
var newUserForm = $userForm.clone();\par
$('#container').append($newUserForm);\par
newUserForm.show(750);\par
\par
\ul\b\fs28 Lab\ulnone\b0\par
\b\fs22 Module 2\b0\par
For module two, we will enhance the interface for our review widget. The updated interface must meet the following goals:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 Provide a configurable number of circles for the user to click on. This can be accomplished by adding a custom attribute to the outer div element that contains the circles\ul\b\par
{\pntext\f0 2.\tab}\ulnone\b0 Allow the number of circles to be updated with a textbox. This is to simulate an administration widget; we will not be adding any form of security to the widget\ul\b\par
{\pntext\f0 3.\tab}\ulnone\b0 The existing functionality of hovering and selection must still work\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0 The starting ratings widget will have 5 circles.\par
When a user enters a new value into the textbox, the number of circles must contain the number provided.\par
BTW, delegate does not support the hover event.\par
\par
\ul\b Tips and tricks\ulnone\b0\par
A solution will not be provided to the lab. But here are some tips we might find helpful.\par
First, we break the requirements down into steps, and then implement each step. For example. for the updated number of circles:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 The user enters a new maximum rating value. We need to add code to read this value when the button is clicked\ul\b\par
{\pntext\f0 2.\tab}\ulnone\b0 Once we have the new maximum value, we need to remmove the existing circles, and then add in the appropriate number of new circles\ul\b\par
{\pntext\f0 3.\tab}\ulnone\b0 We need to ensure that the new circles still work with the event handler for mousing over, clicking and mousing out of the circles\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0 Here are some methods that we may find useful:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 get\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 delegate\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 mouseenter\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 mouseleave\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 on\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 val\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 empty\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 after\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 append\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 prepend\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0 Please note that not all of the functions above are needed for the answer. We may also find other functions that can be used to create a solution.\par
\par
\ul\b\fs32 Module 3\ulnone\b0\par
\ul\b\fs28 Using promises\ulnone\b0\par
\ul\b\fs22 Asynchronous concepts in jQuery\ulnone\b0\par
Many operations we perform both in JavaScript and jQuery can take a non-deterministic amount of time.\par
Some operations, such as animations, take place over a specified amount of time. While we will frequently be responsible for specifying the amount of time an animation will take, there will be times when the length of time will be available.\par
\par
Also, when creating rich web applications, we'll frequently access server resources from our scripts. When we add such functionality, we don't know how long the server is going to take to process the request and return a value.\par
\line When those types of operations take place, we don't necessarily care how long they're going to take, but we need to execute code when they complete. This is where promises come into play.\par
\par
A promise is an object returned by functions in jQuery that take a long or variable amount of time. By using a promise, we can ensure our code executes whenever the operation completes, be notified of its success or failure, or potentially receive update about an operation's progress.\par
\par
Besides the built-in functions that return promises, jQuery also offers us a deferred object. A deferred object allows us to create our own long running operations, allowing developers to use the same patterns provided by the promise object, and be updated when our operation completes.\par
\par
We're going to start out exploration of asynchronous programming in jQuery by introducing promises. We'll then see how we can create our own functions that return a promise through use of the deferred object. As part of this, we will also discuss the concept of a web worker, which is an HTML5 feature allowing web developers to simulate threads in a web browser.\par
\par
\ul\b Promises\ulnone\b0\par
A promise is a programming pattern in which a long runnning operation "promises" to let us know when it has completed its work.\par
\par
\b Long running operations\b0\par
Any jQuery function that runs over a long period of time, such as an animation, or communicates with a remote server, such as Ajax calls, returns a promise. The promise object offers several events that are raised when the operation is completed, or if there is a progress update.\par
\par
\b Three common Promise events\b0\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 done (operation has completed successfully)\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 fail (operation completed unsuccessfully)\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 progress (operation has registered a progress update)\ul\b\par

\pard\sl240\slmult1\par
Promise events\ulnone\b0\par
\b done\b0\par
done is raised when the operation completes successfully. done accepts one or more event handler functions. The event handler can appect one or more parameters, which will contain whatever data the promise object has returned. For example, when making Ajax calls, we will be able to access the data returned by the server in the event handler's parameter. The data returned is determined by the operation.\par
\par
//code to obtain the promise object\par
promise.done(function(data)\{\par
\tab //data will contain the data returned by the operation\par
\});\par
\par
\b fail\b0\par
fail is raised when the operation has completed with an error.\par
\par
Like done, fail accepts one or more parameters. The parameters' values will be determined by the operation.\par
//code to obtain promise object\par
promise.fail(function(data)\{\par
\tab //data will contain the data returned by the operation\par
\});\par
\par
\b progress\b0\par
progress is raised when the operation  raises an alert about its current state. Not all operators raise progress events.\par
\par
Like done and fail, progress allows us to specify one or more event handlers, each optionally accepting parameters. The parameter values are set by the operation.\par
\par
//code to obtain promise object\par
promise.progress(function(data)\{\par
\tab //data will contain the data returned by the operation\par
\});\par
\par
\b chaining\b0\par
We can add done and fail (and potentially progress) event handlers by chaining the method calls as demonstrated below\par
//code to obtain promise object\par
promise.done(function(data)\{\par
\tab //success\par
\}).fail(function(data)\{\par
\tab //failure\par
\});\par
\par
\b then\b0\par
then is a single function allowing us to register done, fail, and progress event handlers in one call. The sample below is identical to the chaining demonstration above.\par
promise.then(function(data)\{\par
\tab //success\par
\}, function(data)\{\par
\tab //failure\par
\});\par
\par
\ul\b\fs28 Web workers\ulnone\b0\par
\ul\b\fs22 Introducing Web Workers\ulnone\b0\par
This section introduces the concept of HTML5 web workers.\par
\par
\b threading\b0\par
Threading is a basic programming concept that allows developpers to execute code on a separate process. Threading is extremely helpful when working with operations that either require additional processing power, or may take a long amount of time.\par
\par
Applications typically start with a single thread that is used to execute code and update the user interface. If an operation is long running, and it executes on that thread, the user interface isn't able to be updated, and thus freezes. This provides a bad experience for the user. By using separate threads, we can execute our long running code elsewhere, allowing the user interface to still be responsive to the user.\par
\par
As mentioned above, threading is an exremely powerful tool. Unfortunately, this tool can easily be mismanaged or abused, leading to degraded performance or potential security risks. This poses a challenge when working with web applications, in which users execute code (JavaScript) without knowing the developer of that code. Allowing threading in a browser could create an undesirable experience for the user. As a result, browsers don't allow JavaScript to use threads.\par
\par
This is where web workers come into play.\par
\par
Web workers simulate a thread. They kind of say "Hey, we have a script that is going to take a little bit of time and we'd like to run asynchronously on some separate thread."\par
We don't actually get control over the thread itself. We implement this through a very simple messaging system.\par
\par
The worker also has limitations on what it's able to do. In particular, it isn't able to update the UI. It isn't also able to access certain objects, like the document object or the window object.\par
\par
The worker script is in another file and the original file refers to it when creating the worker. Both files have eventListeners to make sure that messages are received on both ends. The messages are passed as parameters for the EventListener. What the eventListener is looking for is 'message'. If we want to read what is sent in the message, we have to use parameterName.data. \par
\par
We can pass messages between the worker and the main JS using worker/self.postMessage('whatever message')\par
\par
\ul\b Creating a web worker\ulnone\b0\par
A web worker is made up of two components, the parent or calling script, and the worker ot executing script. The worker runs in an environment similar to a separate thread, and does not have direct access to the calling environment or the UI. Web workers use a messaging system to pass information to and from the worker.\par
\par
\b Creating the worker script\b0\par
To create a web worker, we create a separate JavaScript file. This file will contain the code that will execute in the worker environment. The code in the file will execute immediately when the worker object is created from the callling script. As a result, if we wish to defer execution in a worker, the code will need to be contained inside of a function.\par
\par
\b self\b0\par
The web worker environment provides an object named self, which represents the worker. self has one function and one event.\par
\par
The worker provides a function named postMessage that is used to send data to the calling environment. postMessage accepts most data types, including JavaScript objects.\par
//send a signal back to the calling script\par
self.postMessage('hello from the worker!');\par
\par
The worker offers one event, message. message is raised when the calling script has sent a message to the worker. message is raised when the calling environment calls postMessage, and this almost any type of object can be received. The data passed into postMessage is available by using the data property of the event object.\par
\par
//Receive a message from the calling environment\par
self.addEventListener('message', function(e) \{\par
\tab //the data property will contain the data passed from the calling script\par
\});\par
\par
Web workers can pass any JSON object. Don't have events for start and end\par
Stop a worker:\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 From page: worker.Terminate()\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 From worker: self.close()\ul\b\par

\pard\sl240\slmult1\par
Calling a web worker\b0\par
\ulnone To call a web worker, we create an instance of the HTML5 worker object. Because web workers are a relatively new development, it is a best practice to first check to see if the browser supports web workers. This can be done by testing if Worker is equal to null, meaning it doesn't exist. If worker is null, we know the browser doesn't support web workers.\par
\par
//Test if the browser supports web workers\par
if(Worker == null)\{\par
\tab alert('You need to upgrade your browser!');\par
\}else\{\par
\tab //do your work here\par
\}\par
\par
\b Creating an instance of the Worker object\b0\par
The constructor for Worker accepts one parameter, the location of the script it will load into the worker space. We have to remember that the script will execute immediately, so unless we're uncertain it's been built to allow us to start it manually, we shouldn't create the instance until the last possible moment.\par
\par
var worker = new Worker('script-location.js');\par
\par
Similar to what we've seen already, the worker object offers a postMessage method to send data to the worker space, and an event message that is raised when the worker sends a message back to the calling page. The parameter we pass to postMessage is retrieved by using the data property of the event object in the message event handler.\par
\par
//Register event handler\par
worker.addEventListener('message', function(e)\{\par
\tab $('#output').append('<li>' + e.data + '</li>');\par
\});\par
\par
worker.postMessage('Started!');\par
\par
\ul\b Web worker design practices\ulnone\b0\par
\b Creating a web worker that accepts status messages\b0\par
As we may have noticed, the web worker doesn't provide a built-in structure for handling common events, such as start and finish. However, the worker's simple messaging system allows us to easily build our workers to perform the operations we need, and add our own system to manage start and stop events.\par
\par
Quite frequently, we will want to delay the execution of the worker script until the caller sends a signal to start. We must remember, when our worker script is loaded, the script is run immediately. We can change this behavious by adding a simple check to the worker for a start message.\par
\par
Because JavaScript is weakly typed, the data property of the event object passed by the workers doesn't need to be set in advanced. We can set it to our status strings, such as START and STOP when we're sending those types of messages, and use a JavaScript object in data when we need to send other payloads.\par
\par
The script below is one simple implementation of the behaviour described, using simple strings for event management. We can use other objects as we see fit, depending on the complexity of our needs.\par
\par
//worker.js\par
\par
self.addEventListener('message', function(e)\{\par
\tab if(e.data === 'START')\{\par
\tab\tab //start message received\par
\tab\tab //begin work\par
\tab\tab startWork();\par
\tab\}else if(e.data === 'STOP')\{\par
\tab\tab //stop message received\par
\tab\tab //perform cleanup and terminate\par
\tab\tab stopWork();\par
\tab\}else\{\par
\tab\tab //A different message has been received\par
\tab\tab //This is data that needs to be acted upon\par
\tab\tab processData(e.data);\par
\tab\}\par
\});\par
function startWork()\{\par
\tab //code to start performing work here\par
\tab //send a message to the calling page\par
\tab //worker has started\par
\tab self.postMessage('STARTED');\par
\}\par
\par
function stopWork()\{\par
\tab //cleanup code here\par
\tab //stop the worker\par
\tab self.postMessage('STOPPED');\par
\tab self.close();\par
\}\par
\par
function processData(data)\{\par
\tab //perform the work on the data\par
\tab self.postMessage('Processed ' + data);\par
\}\par
\par
\b Calling a web worker that accepts messages\b0\par
One of the great advantages of having a worker that's been built to accept status messages, such as start and stop, is it makes it very easy to get everything set up, and then start the worker process when we're ready to have it run.\par
\par
If we were using the worker that's been designed above, we would use it by following a couple of basic steps:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 Create an instance of Worker, passing in the script\ul\b\par
{\pntext\f0 2.\tab}\ulnone\b0 Add the event handler for the message event. Ensure the event handler can respond to the status messages and normal data.\ul\b\par
{\pntext\f0 3.\tab}\ulnone\b0 When we're ready to start the worker's work, call postMessage('START');\ul\b\par
{\pntext\f0 4.\tab}\ulnone\b0 When we're done, send the stop message by calling postMessage('STOP');\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0 //inside of the HTML\par
var worker = new worker('worker.js');\par
worker.addEventListener('message', function(e)\{\par
\tab if(e.data === 'STARTED')\{\par
\tab\tab //worker has started\par
\tab\tab //sample: update the screen to display the worker started\par
\tab\tab $('#output').append('<div>Worker started</div>');\par
\tab\}else if(e.data === 'STOPPED')\{\par
\tab\tab //worker has been stopped\par
\tab\tab //cleanup work (if needed)\par
\tab\tab //sample: display data on screen\par
\tab\tab $('#output').append('<div>Worker stopped</div>');\par
\tab\}else\{\par
\tab\tab //Normal message. Act upon data as needed\par
\tab\tab //Sample: display data on screen\par
\tab\tab $('#output').append('<div>' + e.data + '</div>');\par
\tab\}\par
\});\par
\par
//When we're ready, we can send the start message\par
worker.postMessage('START');\par
\par
//Send data as needed\par
worker.postMessage('sample data');\par
\par
//Stop the worker when we're done\par
worker.postMessage('STOP');\par
\par
\ul\b\fs28 Using deferred\par
\fs22 Returning promises\ulnone\b0\par
If we are creating a long running function, we can return a promise, allowing the caller to be alerted to your operations status, or when it complets. We return, and manage, a promise by creating an instance Deferred\par
\b\par
Deferred\b0\par
Deferred and promise seem very similar, and they are. The difference between the two is who uses which. Deferres is used to create, and manage, a promise object. A promise object is returned by a long running operation, and only allows us to register event handlers.\par
\par
To put this another way, Deferred is the server side. When create a long running function that will be called by other developers, we'll use Deferred to return a promise. We'll use the Deferred object to update clients when our function completes (or when we want to send a progress signal).\par
\par
Continuing the analogy, promise is the client side. When we call a long running function, it will return a promise. We will use the promise to be alerted, and execute code, when that long running function completes (or sends a progress signal).\par
\par
\ul\b Using deferred\ulnone\b0\par
If we are creating a function that may take a long time to execute, it's best to return a promise. That makes it easier for developers who call our function, as they can use the promise events.\par
\par
One nice thiing about jQuery is the developers of the API follow their own best practices. As a result, if we execute an operation, such as an Ajax call, the function will return a promise. If we are creating a function that will be wrapping such a call, we can simply return the promise returned by the function.\par
\par
For example, considering the following jQuery. We create a function that calls slideToggle. slideToggle can take a couple of seconds to execute, depending on how long we tell the operation to take. As a result, it returns a promise, as we saw in an earlier section. Because slideToggle returns a promise object already, we can just use that, rather than creating a Deferred object on our own.\par
\par
function displayMenu()\{\line\tab //just return the promise object\par
\tab return $('#menu').slideToggle(500);\par
\}\par
However, if we are creating a function that will take an unusual amount of time, say one that will be working with graphics, we will want to use Deferred to return a promise to the caller.\par
\par
\b Breaking down using Deferred\b0\par
The basic steps are as follows:\par

\pard 
{\pntext\f0 1.\tab}{\*\pn\pnlvlbody\pnf0\pnindent0\pnstart1\pndec{\pntxta.}}
\fi-360\li720\sl240\slmult1 Create an instance of deferred: var deferred = $.Deferred();\ul\b\par
{\pntext\f0 2.\tab}\ulnone\b0 Start our asynchronous operation, typically using a worker\ul\b\par
{\pntext\f0 3.\tab}\ulnone\b0 Add the appropriate code to detect success and send the success signal: deferred.resolve()\ul\b\par
{\pntext\f0 4.\tab}\ulnone\b0 Add the appropriate code to detect failure and send the failure signal: deferred.reject()\ul\b\par
{\pntext\f0 5.\tab}\ulnone\b0 Return the promise: return deferred.promise();\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0 function beginProcessing()\{\par
\tab //Create deferred object and make sure it's going to be in scope\par
\tab var deferred = new $.Deferred();\par
\par
\tab //Create our worker(just like before)\par
\tab var worker = new Worker('./Scripts/deferred.js');\par
\par
\tab //Register the message event handler\par
\tab worker.addEventListener('message', function(e)\{\par
\tab\tab //simple messaging - if the worker is ready it'll send a message with READY as the text\par
\tab\tab if(e.data === 'READY')\{\par
\tab\tab\tab //no UI code\par
\tab\tab\tab //Progress notification\par
\tab\tab\tab deferred.notify('Worker started');\par
\tab\tab\}else if(e.data === 'COMPLETED')\{\par
\tab\tab\tab //processing is done\par
\tab\tab\tab //No UI code\par
\tab\tab\tab //Completed notification\par
\tab\tab\tab deferred.resolve('Worker completed');\par
\tab\tab\tab worker.terminate();\par
\tab\tab\}\par
\tab\});\par
\tab\par
\tab return deferred.promise();\par
\}\par
\par
\ul\b\fs28 JavaScript Object Notation\par
\fs22 Overview of JSON\ulnone\b0\par
One of the most powerful capabilities JavaScript offers is the ability to make calls to the server. This allows us as developers to create web pages that behave like locally installed applications, and access server-based resources, such as a database, without having to refresh the entire page.\par
\par
The catch, of course, is how do we take our in-memory data and send it to the server, and how do we convert the server's reponse into an in-memory object. This is where JSON comes into play. JSON, or JavaScript Object Notation, can be used to represent the object as a string. The process of converting an in memory object as a string representation, including JSON, is known as serialization.\par
\par
JSON is a language independant, an open standard and it stores data in very basic, key/value pairs. JavaScript provides built-in support for working with JSON by utilizing the JSON object. The JSON object has two main methods, stringify(convert to JSON) and parse(convert to object).\par
\par
\ul\b JSON Syntax\ulnone\b0\par
A JSON object uses a notation that's similar to that of a JavaScript object. If we wanted to create a JavaScript object with two properties, firstName and lastName, we'd use the following code:\par
var person = \{\par
\tab firstName: 'Alex',\par
\tab lastName: 'Costa'\par
\}\par
\par
When using JSON, the property names are strings, rather than variable names. The only difference between the syntax above and below is the quotes around lastName and firstName.\par
\par
var person = \{\par
\tab 'firstName': 'Alex',\par
\tab 'lastName': 'Costa'\par
\}\par
\par
If we wish to create a more complex object, one that contains another object, we simply contain the second object in a new set of curly braces.\par
\par
And, if we want an array, we will use square brackets\par
\ul\b\par
Serializing objects\ulnone\b0\par
JavaScript provides a native utility for converting to JSON (serializing), and converting JSON strings to object (deserializing)\par
\par
To serialize an object, we use JSON.stringify.\par
\par
//Create an instance of Object, a basic JavaScript object\par
var person = new Object();\par
\par
//add properties\par
person.firstName = 'Alex';\par
person.lastName = 'Costa';\par
\par
//serialize\par
var jsonString = JSON.stringify(person);\par
\par
\b Deserializing an object\b0\par
To deserialize JSON, we use JSON.parse. Because JavaScript manages objects dynamically, we don't need to worry about casting the returned object to a class, like we would in other programming languages.\par
\par
//Deserialize a JSON string\par
var newPerson = JSON.parse(jsonString);\par
\par
//access properties as normal\par
$('#first-name-display').text(newPerson.firstName);\par
$('#last-name-display').text(newPerson.lastName);\par
\par
\ul\b\fs28 Calling the server\par
\fs22 Introducing Ajax\ulnone\b0\par
Typically, when we make a call to the server, we need to refresh the entire page. Not only can this impact performance, it can change our user's perception of our pages. In addition, as developers, we'd like to be able to incorporate server-side resources into our pages, allowing us to update individual portions of the page with data, rather than updating the entire page. This is where the XmlHttpRequest object comes into play and Ajax as well.\par
\par
\b Asynchronous JavaScript and XML (Ajax)\b0\par
Ajax is a set of technologies that act together to make it easier for us as developers to make calls to server resources from JavaScript. Breaking down the three words that make up the acronym, we'll notice we have asynchronous (which jQuery simplifies through the use of promises), JavaScript and XML. XML is probably the one that doesn't fit, as XML is typically not a preferred mechanism for serialization. As we've seen, we typically want to use JSON, as it's more compact and native to JavaScript.\par
\par
\b Basic data retrieval\b0\par
The most basic Ajax operation we can perform using jQuery is get. get contacts the URL we provide, and passes the string the server returns into the parameter we'll use for our event handler. get accepts multiple parameters, but the two we'll most commonly use are the URL we wish to call, and an event handler that will be executed on success.\par
\par
$.get(\par
\tab 'some-url', //The URL to call\par
\tab function(data)\{ //Success event handler\par
\tab\tab //the data parameter contains the string\par
\tab\tab $('#output').text(data);\par
\par
\tab\}\par
);\par
\par
\b jQuery Ajax and promises\par
\b0 All jQuery Ajax calls return a jQuery promise. This means we can use done for our success event handler and fail to catch any errors. The two code samples perform the same operations.\par
\par
//Option one (pass the success function as a parametere\par
$.get('some-url', function(data)\{$('#output').text(data);\});\par
\par
//Option two (use the done function of the promise)\par
$.get('some-url').done(function(data)\{$('#output').text(data);\});\par
\par
\ul\b Retrieving JSON objects\ulnone\b0\par
As we've discussed, JavaScript offers native support for serialization to and from JSON. jQuery builds on top of that, allowing us to easily retrieve JSON objects from the server by using getJSON.\par
\par
\b getJSON\b0\par
To retrieve a JSON object, we can use getJSON. getJSON accepts several parameters, but the most common two that we'll provide are the URL we need to call, and an event handler for success.\par
Just as we discussed with get, getJSON returns a promise, meaning we can use done and fail as an alternative.\par
\par
Because getJSON is expecting JSON data,, it automatically deserializes the object, meaning we do not need to call JSON.parse.\par
\line If we were calling a server that was going to return a Person object, with properties of firstName and lastName, we could use the sample code below:\par
\par
$.getJSON('/api/demo', function(person)\{\par
\tab $('#first-name').val(person.firstName);\par
\tab $('#last-name').val(person.lastName);\par
\});\par
\par
Note: Uses HTTP Get to request data\par
\par
\b HTTP verbs\b0\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 Most common: GET and POST\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 PUT and DELETE also exist to comple all CRUD operations for a REST API\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 Remember: GET isn't just used to retrieve data, and POST isn't just used to upload data\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 Both GET and POST send and receive data\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 what GET and POST indicate is how the data will get to the server from the client\ul\b\par
{\pntext\f1\'B7\tab}\ulnone\b0 additionally, they may indicate the operation we wish to perform when using a REST API\ul\b\par

\pard\sl240\slmult1\par
\ulnone\b0\par
\ul\b Making server calls\ulnone\b0\line At this point, if we're new to making server calls through JavaScript or other technologies, we might have a few questions about how we're supposed to know where the data is, what URLs we should use, etc. The answer is, well, it depends.\par
\par
\b Finding the right URL\b0\par
Probably the most common question we get is "How do I know where to go find data?" Fortunately this is a much easier question to answer than it seems, and it's in the form of a question, "What do we want to do?"\par
\par
When we're trying to discover services that we can call, we should approach it like we would a user. For example, if we asked someone where to track a pacakge shipment or where to find sports scores, we would receive a couple of different answers.\par
\par
We start by determining what data we need, and then we start our investigation that way. When we find a service that offers the necessary data, they will provide documentation, containing the URLs we need to call to obtain specific types of data, what the data will look like, etc. They'll often provide a sandbox as well that we can use to practice and play.\par
\par
Most commonly we'll be calling our own server and accessing our own organization's data. Then the answer becomes even easier: we just have to talk with the developer who created the server side code that we need to call. They can provide all the information we need.\par
\par
\ul To get technical\par
\ulnone When we start digging into making server calls, retrieving and uploading data, things can get a bit confusing pretty quickly. We may have some questions about how things work behind the scenes. Below we'll find some basic information about various standards and how to use them. However, a full discussion on REST and other APIs is beyond the scope of the course.\par
\par
\b Verbs\b0\par
As we discussed in the prior module, HTTP offers several "verbs", with the two most common being GET and POST. Those two names can cause some confusion, as they both have meanings in English. Get of course means retrieving something, and post means to put something somewhere. Unfortunately, from a technical sense, that is not what GET and POST mean whenn they're related to HTTP.\par
\par
GET and POST in HTTP terms are about how to send data to the server, not a determination of the server sending us data. The server will always send us data, be it a status code, string data, or a JSON object. GET and POST determine how we as the caller are going to send data to the server.\par
\par
Get limits us to sending data in the URL only. Because the data can only be in the URL, we are not only restricted in the amount of data we're able to send, but in the data types. Large amounts of data cannot be sent in the URL.\par
\par
POST on the other hand allows us to send data both in the URL, but also in what's known as the header. The header is information that's sent behind the scenes from the client to the server, and can be used to send almost any type of data, including binary data.\par
\par
But, and we want to repeat this, both GET and POST return data. The difference between the two is how we're allowed to send data to the server.\par
\par
\b HTTP and REST APIs\b0\par
As we discussed above, if we want to access data on a particular service, and need to figure out how to send data, what URLs to use, what data we're able to send, and what data will be sent to us, we'll want to check the documentation provided by the service.\par
\par
Needless to say, that can get a bit overwhelming, as anyone who is implementing a service can create their own API. Each API can be completely different than any other API that's been implemented. To try and provide some consistency, some standards have been set around HTTP calls.\par
\par
The most common set of rules in in working with data. HTTP provides several verbs, including GET, POST, PUT and DELETE. Many servers perform specific operations behind the scenes based on the verb that we use. GET will retrieve objects, POST will create a new object, PUT will update an existing object, and DELETE will delete an object.\par
\par
Building upon those common operations, the W3C has established a specification called REST. REST provides for various standards to provide event more consistency when making server calls.\par
\par
The big thing to remember is nobody is obligated to follow any of these standards. We will find that most services will make good faith efforts to abide by the guidelines set forth by REST, but there may be differences in their implementation.\par
\par
\ul\b Posting data\ulnone\b0\par
If the service we're using follows the standard REST practices, we'll notice that we can create a new object by calling POST. Or, if we're trying to upload a binary object, such as an image, we're forced to use POST, as GET won't allow that type of data to be uploaded.\par
\par
\b post\b0\par
jQuery's post function uploads the data we provide by using the HTTP POST verb. Like getJSON, it also passes the JSON object returned by the server into the parameter for the event handler. And, just like all of the Ajax calls we've seen, post also returns a promise.\par
\par
Because jQuery is aware of the fact we're probably going to use JSON, we'll notice there is no need to call JSON.stringify or JSON.parse; jQuery handles that automatically for us.\par
\par
//get the data we need to send\par
var person = \{firstName: 'Alex', lastName: 'Costa'\};\par
\par
//Call POST\par
$.post('URL', //pass the URL we need to access\par
\tab person, //pass in the data to send via POST\par
\tab function(data)\{\par
\tab\tab //success event handler\par
\tab\tab //parameter contains value returned by server\par
\tab\}\par
);\par
\par
\ul\b Ajax Events\ulnone\b0\par
When making Ajax calls, we may need to update page content or change the availability of controls such as buttons when calls start or complete. jQuery Ajax offers several global events.\par
\par
\b Start events\b0\par
The two starting events are ajaxStart and ajaxSend. ajaxStart is raised when the first Ajax call is being made. ajaxSend is raised each time an Ajax call is made.\par
\par
\b Completion events\par
\b0 jQuery Ajax offers two main events when each Ajax call is finished, ajaxSuccess, which is raised when a call succeeds ,and ajaxError, which is raised when a call fails.\par
\par
ajaxComplete is raised when each Ajax calls completes, regardless of success or failure. ajaxStop is raised when all calls are completed.\par
\par
$(document).ajaxSend(function()\{\par
\tab //raised when a call starts\par
\tab $('#status').append('<div>Call started</div>');\par
\}).ajaxComplete(function()\{\par
\tab //raised when a call completes\par
\tab $('#status').append('<div>Call completed</div>');\par
\});\ul\b\par
}
 